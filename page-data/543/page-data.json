{"componentChunkName":"component---src-templates-post-jsx","path":"/543/","result":{"data":{"site":{"siteMetadata":{"title":"Cave"}},"markdownRemark":{"id":"de9f8ea3-5e51-5f00-bd3e-21460169eef0","excerpt":"1. 문제 설명 트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)  2. 제약 조건 한 트리에 있는 노드의 개수는 0개 이상 개 이하다. 노드의 값은  이상  이하다. 3. 접근 트리의 지름은 정의상 어떤 리프 노드에서 다른 리프 노드까지의 경로일 수밖에 없다. 만약 어떤 지름이 리프 노드…","html":"<h2>1. 문제 설명</h2>\n<p>트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 652px; '>\n      <a class='gatsby-resp-image-link' href='/static/65932f7cc9f939e6218d6408f2af3d5f/43b96/examples.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 86.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABTklEQVQ4y51TCW6DMBDk/y+s1DSoCbfBN+A7nUCE0khNaKzVMos87OzYZFrrpu2U1pf/r8x7N06T936t53kehsE5t4u8oZQSMphFUQgh3iETQpqmeYeslwVMKd0GeU3GVvSE4JUDclmW+pWLN7IxJs/z0+kUY0QJ2cCMsV1kpRTnHA3xFZQhhHEckV+Q0Qr7+r5HYa0FQF7NW/MzMhQej184oXXy8/mMycHf5TYEl2W13jDvQ9d1dd3gkqBpTOlJYGXGuY/PQ90RJhQTggyMK218mK011hnnZ+vmO7BFiDHzIRRVXdQtFZIyQZkkAwXuKRtgIRdMSC4U3nCpH8k4zKppKefwFubhW84hRZR4wAXksADk9GtdMpwNFxL/Q4zpyl4svt+xxA08zmydP+TfVUuYVNApxwmSJmP/CLfFVTYUKj3Oxvqr1Ah1OwOdfwAl/OO0mYKW6AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='트리의 지름 예시' title='트리의 지름 예시' src='/static/65932f7cc9f939e6218d6408f2af3d5f/43b96/examples.png' srcset='/static/65932f7cc9f939e6218d6408f2af3d5f/e7570/examples.png 170w,\n/static/65932f7cc9f939e6218d6408f2af3d5f/f46e7/examples.png 340w,\n/static/65932f7cc9f939e6218d6408f2af3d5f/43b96/examples.png 652w' sizes='(max-width: 652px) 100vw, 652px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>트리의 지름 예시</figcaption>\n  </figure></p>\n<hr>\n<h2>2. 제약 조건</h2>\n<ol>\n<li>한 트리에 있는 노드의 개수는 0개 이상 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span></span></span>개 이하다.</li>\n<li>노드의 값은 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">-100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> 이상 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> 이하다.</li>\n</ol>\n<hr>\n<h2>3. 접근</h2>\n<p>트리의 지름은 정의상 <strong>어떤 리프 노드에서 다른 리프 노드까지의 경로</strong>일 수밖에 없다. 만약 어떤 지름이 리프 노드가 아닌 노드를 포함하고 있다면, 리프 노드를 선택할 경우 언제나 거리가 늘어나기 때문에 모순이 발생하기 때문이다.</p>\n<p>또한, 트리의 지름은 반드시 <strong>어떤 서브 트리의 루트 노드</strong>를 지나야 한다. 그 루트 노드가 트리 전체의 루트 노드일 필요는 없지만, 한 리프 노드가 다른 리프 노드와 만나기 위해서는 루트 노드를 지나는 것이 필연적이기 때문이다.</p>\n<p>따라서 트리의 모든 노드를 루트 노드라고 가정하고 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구한 후, 그 합의 최댓값을 구하면 트리의 지름을 얻을 수 있을 것이다.</p>\n<p>정리하면, 필요한 연산은 아래와 같다.</p>\n<ol>\n<li>한 노드에서 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구하는 연산</li>\n<li>1.에서 구한 최대 깊이의 전체 최댓값을 구하는 연산</li>\n</ol>\n<hr>\n<h2>4. 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    \n    <span class=\"token keyword\">int</span> maxDepth <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">diameterOfBinaryTree</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> maxDepth<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// 전체 최댓값 갱신</span>\n        maxDepth <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxDepth<span class=\"token punctuation\">,</span> left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// 양쪽 서브 트리의 깊이 중에서 가장 큰 값 + 자기 자신(1)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>5. 참고한 링크</h2>\n<p>포럼에서 <a href=\"https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth\">가장 많은 업보트를 받은 코드</a>를 참고했다.</p>\n<hr>","frontmatter":{"title":"[L543] Diameter of Binary Tree","date":"May 01, 2021","update":"May 01, 2021","tags":["leetcode"],"series":"트리를 활용한 문제"},"fields":{"slug":"/543/","readingTime":{"minutes":1.23}}},"seriesList":{"edges":[{"node":{"id":"de9f8ea3-5e51-5f00-bd3e-21460169eef0","fields":{"slug":"/543/"},"frontmatter":{"title":"[L543] Diameter of Binary Tree"}}},{"node":{"id":"d4209dfd-282e-58b9-a94a-1bbd1d31f8b1","fields":{"slug":"/617/"},"frontmatter":{"title":"[L617] Merge Two Binary Trees"}}}]},"previous":{"fields":{"slug":"/234/"},"frontmatter":{"title":"[L234] Palindrome Linked List"}},"next":{"fields":{"slug":"/617/"},"frontmatter":{"title":"[L617] Merge Two Binary Trees"}}},"pageContext":{"id":"de9f8ea3-5e51-5f00-bd3e-21460169eef0","series":"트리를 활용한 문제","previousPostId":"4d03d26c-75c0-5f27-85ff-d90ef4db683b","nextPostId":"d4209dfd-282e-58b9-a94a-1bbd1d31f8b1"}},"staticQueryHashes":[]}