{"componentChunkName":"component---src-templates-post-jsx","path":"/l-234/","result":{"data":{"site":{"siteMetadata":{"title":"Cave"}},"markdownRemark":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","excerpt":"1. 문제 설명 주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.  2. 제약 조건 리스트 내 노드의 개수는 1개부터 개까지 존재한다. 한 노드의 값은 0부터 9까지다. (선택) 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다. 3. 접근 9. Palindrome Number와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트…","html":"<h2>1. 문제 설명</h2>\n<p>주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 619px; '>\n      <a class='gatsby-resp-image-link' href='/static/919ddc04dd6ea7dbd3938514134c8d91/80833/examples.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 59.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABMUlEQVQoz5WSi46DIBBF+/+fWE2rVkUEfAEKw6Md7Ka7Zjdt9mYcbpSL44mnOyrGRUoxDMaa+390ivvCGM8vl82ksNZqHKcQ0hOl1LIsMSY/7zqE8fLe95RyzintCCHn87lpGkop9jzPsTPGyrIsioKx3hhzCKOEEG3bKqW9D6TryqpaN+OcJ3hE21oLWB1NAnAxvsbe7bTI7FqSnlMu0ItxXhEAuA1c6hb2ngzet+AOb96sFeOk9Ko33Oatc+B9KjTfPpX1zodwCDPOq1stldrZx/ia7D3t54K06rpGtgCAH4+QrLXPgz6EkTZyRhhsV5ZlyFZr/Tn8BWyar9VtGGf8bCYGnn4YQDC/C5E47w9jz1LmRUUob7pe6m01sAGs9o/SBqw7hn8KJwkxhvhOz50POTm5DjMQzzAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='팰린드롬 리스트와 그렇지 않은 리스트' title='팰린드롬 리스트와 그렇지 않은 리스트' src='/static/919ddc04dd6ea7dbd3938514134c8d91/80833/examples.png' srcset='/static/919ddc04dd6ea7dbd3938514134c8d91/e7570/examples.png 170w,\n/static/919ddc04dd6ea7dbd3938514134c8d91/f46e7/examples.png 340w,\n/static/919ddc04dd6ea7dbd3938514134c8d91/80833/examples.png 619w' sizes='(max-width: 619px) 100vw, 619px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>팰린드롬 리스트와 그렇지 않은 리스트</figcaption>\n  </figure></p>\n<hr>\n<h2>2. 제약 조건</h2>\n<ol>\n<li>리스트 내 노드의 개수는 1개부터 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>개까지 존재한다.</li>\n<li>한 노드의 값은 0부터 9까지다.</li>\n<li><span style=\"color:grey\">(선택)</span> 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다.</li>\n</ol>\n<hr>\n<h2>3. 접근</h2>\n<p><a href=\"https://leetcode.com/problems/palindrome-number/\">9. Palindrome Number</a>와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트 내 노드의 개수가 열 개를 넘어가면 자연수로 쳤을 때 10억을 훌쩍 넘기기 때문이다. 하지만 문제의 본질은 같다.</p>\n<p>관건은 입력받은 리스트의 절반을 <strong>뒤집었을 때, 그 뒤집은 부분이 나머지 부분과 같은지</strong> 확인하는 것이다.</p>\n<ul>\n<li>홀수 개 노드의 경우 : 1 - 2 - 4 - 2 - 1</li>\n<li>짝수 개 노드의 경우 : 1 - 5 - 5 - 1</li>\n</ul>\n<p>9번 문제에서는 입력받은 정수에 모듈로 연산과 나눗셈 연산을 시행하여 간단하게 뒤집을 수 있었지만, 이 문제는 <strong>리스트</strong>가 주어지므로 아래와 같은 연산이 필요하다.</p>\n<ol>\n<li>리스트의 중간 노드를 찾아 그 위치를 반환하는 연산</li>\n<li>리스트의 절반을 뒤집는 연산</li>\n</ol>\n<hr>\n<h3>3-1. 리스트의 중간 노드를 찾는 연산</h3>\n<p>가장 먼저 떠오른 방법은 리스트를 순회하여 노드의 총 개수를 구하는 것이었다.</p>\n<p>그렇게 구한 노드의 개수가 홀수 개인 경우 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{2} + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>번째 노드가 중간 노드이고, 짝수 개인 경우에도 마찬가지로 해당 노드가 뒤집어야 하는 부분의 시작점이다.</p>\n<p>그러나 이 방법은 중간 노드를 한 번의 순회만으로 찾을 수 없다.</p>\n<p>그렇게 해서 나온 방법이 바로 <strong>두 개의 포인터</strong>를 사용하는 방법이다. slow 포인터는 노드를 1개씩 방문하고, fast 포인터는 노드를 2개씩 건너뛰면서 방문한다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/05cf284bb392aaa1155493b7a3c8be19/720c7/two_pointers.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 44.11764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9NAo//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAACAwEAAAAAAAAAAAAAAAABEAAxgZH/2gAIAQEAAT8hOzrFL//aAAwDAQACAAMAAAAQIw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAQUAAAAAAAAAAAAAAAABEQAQITFB/9oACAEBAAE/EEzh24UMpM8PIoILa7f/2Q=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='두 포인터가 이동하는 모습' title='두 포인터가 이동하는 모습' src='/static/05cf284bb392aaa1155493b7a3c8be19/a22ce/two_pointers.jpg' srcset='/static/05cf284bb392aaa1155493b7a3c8be19/0b705/two_pointers.jpg 170w,\n/static/05cf284bb392aaa1155493b7a3c8be19/31389/two_pointers.jpg 340w,\n/static/05cf284bb392aaa1155493b7a3c8be19/a22ce/two_pointers.jpg 680w,\n/static/05cf284bb392aaa1155493b7a3c8be19/29373/two_pointers.jpg 1020w,\n/static/05cf284bb392aaa1155493b7a3c8be19/720c7/two_pointers.jpg 1324w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>두 포인터가 이동하는 모습</figcaption>\n  </figure></p>\n<p>이렇게 하면 slow 포인터는 언제나 fast 포인터의 중간 지점을 가리키게 된다. 뒤집을 때는 slow 포인터의 다음 노드를 시작점으로 한다.</p>\n<hr>\n<h3>3-2. 리스트의 절반을 뒤집는 연산</h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/cf46e3df9af758319dea6b7db69c409b/39368/reverse-operation.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 38.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAduQuD//xAAXEAADAQAAAAAAAAAAAAAAAAAAASEQ/9oACAEBAAEFAqK5/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAEDEh/9oACAEBAAE/Ieidj6Yr/9oADAMBAAIAAwAAABCDz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFBUf/aAAgBAQABPxAo6ALuxWNDOwK9n//Z'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='flip 연산의 원리' title='flip 연산의 원리' src='/static/cf46e3df9af758319dea6b7db69c409b/a22ce/reverse-operation.jpg' srcset='/static/cf46e3df9af758319dea6b7db69c409b/0b705/reverse-operation.jpg 170w,\n/static/cf46e3df9af758319dea6b7db69c409b/31389/reverse-operation.jpg 340w,\n/static/cf46e3df9af758319dea6b7db69c409b/a22ce/reverse-operation.jpg 680w,\n/static/cf46e3df9af758319dea6b7db69c409b/29373/reverse-operation.jpg 1020w,\n/static/cf46e3df9af758319dea6b7db69c409b/39368/reverse-operation.jpg 1205w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>flip 연산의 원리</figcaption>\n  </figure></p>\n<p>A부터 이동하면서 위와 같은 순서로 포인터를 변경하면 리스트를 뒤집을 수 있다.</p>\n<hr>\n<h2>4. 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">||</span> head<span class=\"token operator\">-></span>next <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    \n        ListNode<span class=\"token operator\">*</span> middle <span class=\"token operator\">=</span> <span class=\"token function\">findMiddle</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> half <span class=\"token operator\">=</span> <span class=\"token function\">flipList</span><span class=\"token punctuation\">(</span>middle<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">return</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">findMiddle</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        ListNode<span class=\"token operator\">*</span> slow <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> fast <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">-></span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token operator\">-></span>next<span class=\"token operator\">-></span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token operator\">-></span>next<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> slow<span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">flipList</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        ListNode<span class=\"token operator\">*</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> update <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            store <span class=\"token operator\">=</span> start<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            start<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n            update <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n            start <span class=\"token operator\">=</span> store<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> update<span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> ListNode<span class=\"token operator\">*</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>half <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">-></span>val <span class=\"token operator\">!=</span> half<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            half <span class=\"token operator\">=</span> half<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>5. 예외 처리 및 주의사항</h2>\n<p>리스트에 노드가 없거나 노드가 하나인 경우, 무조건 참을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">||</span> head<span class=\"token operator\">-></span>next <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한, <code class=\"language-text\">half</code>는 리스트의 중간부터 시작하기 때문에 끝을 더 빨리 맞닥뜨리게 되므로, <code class=\"language-text\">half</code>를 기준으로 반복문의 조건을 설정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> ListNode<span class=\"token operator\">*</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>half <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>6. 재귀를 활용한 풀이</h2>\n<p>재귀로 풀이할 수도 있다. 이 경우 콜 스택 때문에 공간 복잡도는 O(n)이 되지만, 아주 짧은 코드로 문제를 해결할 수 있다는 점에서 매력적이다. <a href=\"https://leetcode.com/problems/palindrome-linked-list/discuss/64490/My-easy-understand-C%2B%2B-solution\">아래 코드</a>는 포럼에서 가장 많은 추천을 받은 C++ 재귀 코드로, 변수명을 리팩토링하여 가져왔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode<span class=\"token operator\">*</span> forward<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        forward <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> backward<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>backward <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">bool</span> isPal <span class=\"token operator\">=</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>backward<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>forward<span class=\"token operator\">-></span>val <span class=\"token operator\">==</span> backward<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        forward <span class=\"token operator\">=</span> forward<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">return</span> isPal<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 주목해야 할 포인터는 <code class=\"language-text\">forward</code>와 <code class=\"language-text\">backward</code>이다. </p>\n<p><code class=\"language-text\">backward</code>는 리스트의 끝까지 재귀적으로 방문했다가 반환되면서 거꾸로 돌아오고, <code class=\"language-text\">forward</code>는 <code class=\"language-text\">backward</code>가 한 칸씩 뒤로 이동할 때마다 앞으로 이동하는 <strong>전역 변수</strong>다. 따라서 이 둘을 비교하면 주어진 리스트가 팰린드롬인지 알아낼 수 있게 된다.</p>\n<p>이 접근이 상대적으로 비효율적인 이유는 리스트의 절반만 검사하는 게 아니라 첫번째 노드부터 마지막 노드까지 비교를 전부 진행하기 때문인데, 개선하려면 리스트의 중간 노드에서부터 재귀 호출을 시작해야 한다.</p>\n<hr>","frontmatter":{"title":"[L234] Palindrome Linked List","date":"April 30, 2021","update":"April 30, 2021","tags":["leetcode"],"series":"리스트를 활용한 문제"},"fields":{"slug":"/l-234/","readingTime":{"minutes":3.205}}},"seriesList":{"edges":[{"node":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","fields":{"slug":"/l-234/"},"frontmatter":{"title":"[L234] Palindrome Linked List"}}}]},"previous":null,"next":{"fields":{"slug":"/l-617/"},"frontmatter":{"title":"[L617] Merge Two Binary Trees"}}},"pageContext":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","series":"리스트를 활용한 문제","previousPostId":null,"nextPostId":"3835e5aa-10c9-5a4d-874d-0807e08d7067"}},"staticQueryHashes":[]}