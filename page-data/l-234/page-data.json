{"componentChunkName":"component---src-templates-post-jsx","path":"/l-234/","result":{"data":{"site":{"siteMetadata":{"title":"alex-roh.github.io"}},"markdownRemark":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","excerpt":"1. 문제 설명 주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오. 37 2. 제약 조건 리스트 내 노드의 개수는 1개부터 \\(10^5\\)개까지 존재한다. 한 노드의 값은 0부터 9까지다. (선택) 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다. 3. 접근 9. Palindrome Number와 비슷한 문제지만, 접근 방식이 조금 달라…","html":"<h2>1. 문제 설명</h2>\n<p>주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54312875/116727575-b6a66b80-aa1f-11eb-90da-f48a34fd9505.png\" alt=\"37\"></p>\n<hr>\n<h2>2. 제약 조건</h2>\n<ol>\n<li>리스트 내 노드의 개수는 1개부터 \\(10^5\\)개까지 존재한다.</li>\n<li>한 노드의 값은 0부터 9까지다.</li>\n<li><span style=\"color:grey\">(선택)</span> 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다.</li>\n</ol>\n<hr>\n<h2>3. 접근</h2>\n<p><a href=\"https://leetcode.com/problems/palindrome-number/\">9. Palindrome Number</a>와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트 내 노드의 개수가 열 개를 넘어가면 자연수로 쳤을 때 10억을 훌쩍 넘기기 때문이다. 하지만 문제의 본질은 같다.</p>\n<p>관건은 입력받은 리스트의 절반을 <strong>뒤집었을 때, 그 뒤집은 부분이 나머지 부분과 같은지</strong> 확인하는 것이다.</p>\n<ul>\n<li>홀수 개 노드의 경우 : 1 - 2 - 4 - 2 - 1</li>\n<li>짝수 개 노드의 경우 : 1 - 5 - 5 - 1</li>\n</ul>\n<p>9번 문제에서는 입력받은 정수에 모듈로 연산과 나눗셈 연산을 시행하여 간단하게 뒤집을 수 있었지만, 이 문제는 <strong>리스트</strong>가 주어지므로 아래와 같은 연산이 필요하다.</p>\n<ol>\n<li>리스트의 중간 노드를 찾아 그 위치를 반환하는 연산</li>\n<li>리스트의 절반을 뒤집는 연산</li>\n</ol>\n<hr>\n<h3>3-1. 리스트의 중간 노드를 찾는 연산</h3>\n<p>가장 먼저 떠오른 방법은 리스트를 순회하여 노드의 총 개수를 구하는 것이었다.</p>\n<p>그렇게 구한 노드의 개수가 홀수 개인 경우 \\(\\frac{n}{2} + 1\\)번째 노드가 중간 노드이고, 짝수 개인 경우에도 마찬가지로 해당 노드가 뒤집어야 하는 부분의 시작점이다.</p>\n<p>그러나 이 방법은 중간 노드를 한 번의 순회만으로 찾을 수 없다.</p>\n<p>그렇게 해서 나온 방법이 바로 <strong>두 개의 포인터</strong>를 사용하는 방법이다. slow 포인터는 노드를 1개씩 방문하고, fast 포인터는 노드를 2개씩 건너뛰면서 방문한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/54312875/116774493-d7aaa300-aa97-11eb-879f-1ae165cf9ca9.jpg\" alt=\"unnamed\"></p>\n<p>이렇게 하면 slow 포인터는 언제나 fast 포인터의 중간 지점을 가리키게 된다. 뒤집을 때는 slow 포인터의 다음 노드를 시작점으로 한다.</p>\n<hr>\n<h3>3-2. 리스트의 절반을 뒤집는 연산</h3>\n<p><img src=\"https://user-images.githubusercontent.com/54312875/116742448-579e2200-aa32-11eb-94aa-f591d9c31dc3.jpg\" alt=\"5\"></p>\n<p>A부터 이동하면서 위와 같은 순서로 포인터를 변경하면 리스트를 뒤집을 수 있다.</p>\n<hr>\n<h2>4. 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">||</span> head<span class=\"token operator\">-></span>next <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    \n        ListNode<span class=\"token operator\">*</span> middle <span class=\"token operator\">=</span> <span class=\"token function\">findMiddle</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> half <span class=\"token operator\">=</span> <span class=\"token function\">flipList</span><span class=\"token punctuation\">(</span>middle<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">return</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">findMiddle</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        ListNode<span class=\"token operator\">*</span> slow <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> fast <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>fast<span class=\"token operator\">-></span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> fast<span class=\"token operator\">-></span>next<span class=\"token operator\">-></span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            slow <span class=\"token operator\">=</span> slow<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            fast <span class=\"token operator\">=</span> fast<span class=\"token operator\">-></span>next<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> slow<span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    ListNode<span class=\"token operator\">*</span> <span class=\"token function\">flipList</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        ListNode<span class=\"token operator\">*</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        ListNode<span class=\"token operator\">*</span> update <span class=\"token operator\">=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            store <span class=\"token operator\">=</span> start<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            start<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n            update <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n            start <span class=\"token operator\">=</span> store<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> update<span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> ListNode<span class=\"token operator\">*</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>half <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token operator\">-></span>val <span class=\"token operator\">!=</span> half<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            head <span class=\"token operator\">=</span> head<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n            half <span class=\"token operator\">=</span> half<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>5. 예외 처리 및 주의사항</h2>\n<p>리스트에 노드가 없거나 노드가 하나인 경우, 무조건 참을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">||</span> head<span class=\"token operator\">-></span>next <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한, <code class=\"language-text\">half</code>는 리스트의 중간부터 시작하기 때문에 끝을 더 빨리 맞닥뜨리게 되므로, <code class=\"language-text\">half</code>를 기준으로 반복문의 조건을 설정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token function\">isSame</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">,</span> ListNode<span class=\"token operator\">*</span> half<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>half <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>6. 재귀를 활용한 풀이</h2>\n<p>재귀로 풀이할 수도 있다. 이 경우 콜 스택 때문에 공간 복잡도는 O(n)이 되지만, 아주 짧은 코드로 문제를 해결할 수 있다는 점에서 매력적이다. <a href=\"https://leetcode.com/problems/palindrome-linked-list/discuss/64490/My-easy-understand-C%2B%2B-solution\">아래 코드</a>는 포럼에서 가장 많은 추천을 받은 C++ 재귀 코드로, 변수명을 리팩토링하여 가져왔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    ListNode<span class=\"token operator\">*</span> forward<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        forward <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">bool</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>ListNode<span class=\"token operator\">*</span> backward<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>backward <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">bool</span> isPal <span class=\"token operator\">=</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span>backward<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>forward<span class=\"token operator\">-></span>val <span class=\"token operator\">==</span> backward<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        forward <span class=\"token operator\">=</span> forward<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">return</span> isPal<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 주목해야 할 포인터는 <code class=\"language-text\">forward</code>와 <code class=\"language-text\">backward</code>이다. </p>\n<p><code class=\"language-text\">backward</code>는 리스트의 끝까지 재귀적으로 방문했다가 반환되면서 거꾸로 돌아오고, <code class=\"language-text\">forward</code>는 <code class=\"language-text\">backward</code>가 한 칸씩 뒤로 이동할 때마다 앞으로 이동하는 <strong>전역 변수</strong>다. 따라서 이 둘을 비교하면 주어진 리스트가 팰린드롬인지 알아낼 수 있게 된다.</p>\n<p>이 접근이 상대적으로 비효율적인 이유는 리스트의 절반만 검사하는 게 아니라 첫번째 노드부터 마지막 노드까지 비교를 전부 진행하기 때문인데, 개선하려면 리스트의 중간 노드에서부터 재귀 호출을 시작해야 한다.</p>\n<hr>","frontmatter":{"title":"[L234] Palindrome Linked List","date":"April 30, 2021","update":"April 30, 2021","tags":["leetcode"],"series":"리스트를 활용한 문제"},"fields":{"slug":"/l-234/","readingTime":{"minutes":3.16}}},"seriesList":{"edges":[{"node":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","fields":{"slug":"/l-234/"},"frontmatter":{"title":"[L234] Palindrome Linked List"}}}]},"previous":null,"next":{"fields":{"slug":"/l-543/"},"frontmatter":{"title":"[L543] Diameter of Binary Tree"}}},"pageContext":{"id":"7084f71d-baa1-5f45-b08b-25353e41a908","series":"리스트를 활용한 문제","previousPostId":null,"nextPostId":"d2f9d7b0-7c48-5323-9a45-fdb8065bbead"}},"staticQueryHashes":[]}