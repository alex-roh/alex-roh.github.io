{"componentChunkName":"component---src-templates-post-jsx","path":"/l-543/","result":{"data":{"site":{"siteMetadata":{"title":"alex-roh.github.io"}},"markdownRemark":{"id":"d2f9d7b0-7c48-5323-9a45-fdb8065bbead","excerpt":"1. 문제 설명 트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.) 42 2. 제약 조건 한 트리에 있는 노드의 개수는 0개 이상 \\(10^4\\)개 이하다. 노드의 값은 \\(-100\\) 이상 \\(100\\) 이하다. 3. 접근 트리의 지름은 정의상 어떤 리프 노드에서 다른 리프 노드까지의 경로…","html":"<h2>1. 문제 설명</h2>\n<p>트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)</p>\n<p><img src=\"https://user-images.githubusercontent.com/54312875/116781236-a8f2f380-aabc-11eb-8f1b-b0d632b2e4b1.png\" alt=\"42\"></p>\n<hr>\n<h2>2. 제약 조건</h2>\n<ol>\n<li>한 트리에 있는 노드의 개수는 0개 이상 \\(10^4\\)개 이하다.</li>\n<li>노드의 값은 \\(-100\\) 이상 \\(100\\) 이하다.</li>\n</ol>\n<hr>\n<h2>3. 접근</h2>\n<p>트리의 지름은 정의상 <strong>어떤 리프 노드에서 다른 리프 노드까지의 경로</strong>일 수밖에 없다. 만약 어떤 지름이 리프 노드가 아닌 노드를 포함하고 있다면, 리프 노드를 선택할 경우 언제나 거리가 늘어나기 때문에 모순이 발생하기 때문이다.</p>\n<p>또한, 트리의 지름은 반드시 <strong>어떤 서브 트리의 루트 노드</strong>를 지나야 한다. 그 루트 노드가 트리 전체의 루트 노드일 필요는 없지만, 한 리프 노드가 다른 리프 노드와 만나기 위해서는 루트 노드를 지나는 것이 필연적이기 때문이다.</p>\n<p>따라서 트리의 모든 노드를 루트 노드라고 가정하고 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구한 후, 그 합의 최댓값을 구하면 트리의 지름을 얻을 수 있을 것이다.</p>\n<p>정리하면, 필요한 연산은 아래와 같다.</p>\n<ol>\n<li>한 노드에서 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구하는 연산</li>\n<li>1.에서 구한 최대 깊이의 전체 최댓값을 구하는 연산</li>\n</ol>\n<hr>\n<h2>4. 구현</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    \n    <span class=\"token keyword\">int</span> maxDepth <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">diameterOfBinaryTree</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \n        <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> maxDepth<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> <span class=\"token function\">updateMaxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-></span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// 전체 최댓값 갱신</span>\n        maxDepth <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxDepth<span class=\"token punctuation\">,</span> left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// 양쪽 서브 트리의 깊이 중에서 가장 큰 값 + 자기 자신(1)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        \n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<h2>5. 참고한 링크</h2>\n<p>포럼에서 <a href=\"https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth\">가장 많은 업보트를 받은 코드</a>를 참고했다.</p>\n<hr>","frontmatter":{"title":"[L543] Diameter of Binary Tree","date":"May 01, 2021","update":"May 01, 2021","tags":["leetcode"],"series":"트리를 활용한 문제"},"fields":{"slug":"/l-543/","readingTime":{"minutes":1.22}}},"seriesList":{"edges":[{"node":{"id":"d2f9d7b0-7c48-5323-9a45-fdb8065bbead","fields":{"slug":"/l-543/"},"frontmatter":{"title":"[L543] Diameter of Binary Tree"}}},{"node":{"id":"3835e5aa-10c9-5a4d-874d-0807e08d7067","fields":{"slug":"/l-617/"},"frontmatter":{"title":"[L617] Merge Two Binary Trees"}}}]},"previous":{"fields":{"slug":"/l-234/"},"frontmatter":{"title":"[L234] Palindrome Linked List"}},"next":{"fields":{"slug":"/l-617/"},"frontmatter":{"title":"[L617] Merge Two Binary Trees"}}},"pageContext":{"id":"d2f9d7b0-7c48-5323-9a45-fdb8065bbead","series":"트리를 활용한 문제","previousPostId":"7084f71d-baa1-5f45-b08b-25353e41a908","nextPostId":"3835e5aa-10c9-5a4d-874d-0807e08d7067"}},"staticQueryHashes":[]}