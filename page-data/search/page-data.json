{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"1. 문제 설명 2와 5로 나누어 떨어지지 않는 정수 n이 주어졌을 때, 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하여 그 중 가장 작은 수의 자리수를 출력하시오. (e.g., 1, 11, 111...) 2. 제약 조건 2와 5로 나누어 떨어지지 않는 정수 은 을 만족한다. 3. 접근 3-1. 정답이 반드시 존재하는지 여부 파악 1 11 111 1…","fields":{"slug":"/b-4375/"},"frontmatter":{"date":"March 29, 2022","title":"[B4375] 1","tags":["boj","mathematics"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n2와 5로 나누어 떨어지지 않는 정수 n이 주어졌을 때, 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하여 그 중 가장 작은 수의 자리수를 출력하시오. (e.g., 1, 11, 111...)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n2와 5로 나누어 떨어지지 않는 정수 $$n$$은 $$1 ≤ n ≤ 10000$$을 만족한다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n### 3-1. 정답이 반드시 존재하는지 여부 파악\r\n\r\n1 11 111 1111\r\n\r\n1\r\n10 + 1\r\n110 + 1\r\n1110 + 1\r\n\r\n3\r\n\r\n### 3-2. 1로만 이루어진 수의 성질 파악\r\n\r\n### 3-3. 나머지 연산의 성질을 이용한 풀이\r\n\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n-----\r\n\r\n## 5. 예외 처리 및 주의사항\r\n\r\n-----"},{"excerpt":"1. HTML이란? HTML은 Hypertext Markup Language의 약자로, 웹 페이지의 구조를 결정한다. HTML을 구성하는 기본 단위는 태그로, HTML에서 사용할 수 있는 태그들은 이미 정의되어 있다 예컨대  태그는 닫는 태그 가 나오기 전까지 텍스트를 크고 두껍게 강조한다. 이처럼 대부분의 HTML 태그는 아래와 같이 사용되고, 이 묶음…","fields":{"slug":"/html-basic/"},"frontmatter":{"date":"March 27, 2022","title":"HTML의 기초","tags":["vanilla-coding","html"]},"rawMarkdownBody":"\r\n## 1. HTML이란?\r\n\r\nHTML은 Hypertext Markup Language의 약자로, 웹 페이지의 구조를 결정한다. HTML을 구성하는 기본 단위는 태그로, HTML에서 사용할 수 있는 태그들은 이미 정의되어 있다 예컨대 ```<h1>``` 태그는 닫는 태그 ```</h1>```가 나오기 전까지 텍스트를 크고 두껍게 강조한다. 이처럼 대부분의 HTML 태그는 아래와 같이 사용되고, 이 묶음을 ```element```라고 한다.\r\n\r\n1. 여는 태그: 어떤 태그를 사용하는지 명시함\r\n2. 해당 태그가 적용되기를 바라는 텍스트 문구\r\n3. 닫는 태그: 해당 태그가 적용되는 끝 지점을 명시"},{"excerpt":"1. 문제 설명 두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)  2. 제약 조건 병합은 트리의 루트에서부터 이루어져야 한다. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다. 노드의 값은  이상  이하다. 3. 접근 재귀적으로 트리를 DFS 순회하되, 매…","fields":{"slug":"/l-617/"},"frontmatter":{"date":"May 01, 2021","title":"[L617] Merge Two Binary Trees","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)\r\n\r\n![두 이진 트리의 병합 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 병합은 트리의 루트에서부터 이루어져야 한다.\r\n2. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다.\r\n3. 노드의 값은 $$-10^4$$ 이상 $$10^4$$ 이하다.\r\n\r\n-----\r\n## 3. 접근\r\n\r\n\r\n재귀적으로 트리를 DFS 순회하되, 매 단계마다 새로운 노드를 만들었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        TreeNode* root;\r\n        \r\n        if(root1 != nullptr && root2 != nullptr){\r\n            root->val = root1->val + root2->val;\r\n            root->left = mergeTrees(root1->left, root2->left);\r\n            root->right = mergeTrees(root1->right, root2->right);\r\n        }\r\n        else if(root1 != nullptr && root2 == nullptr){\r\n            root->val = root1->val;\r\n            root->left = mergeTrees(root1->left, nullptr);\r\n            root->right = mergeTrees(root1->right, nullptr);\r\n        }\r\n        else if(root1 == nullptr && root2 != nullptr){\r\n            root->val = root2->val;\r\n            root->left = mergeTrees(nullptr, root2->left);\r\n            root->right = mergeTrees(nullptr, root2->right);\r\n        }\r\n        \r\n        return root;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n그러나 이 방식은 좋지 않은데, 굳이 새로 만들 필요가 없는 노드를 생성하고 있다는 점에서 낭비가 발생하기 때문이다. 두 트리의 노드가 겹치지 않으면 기존의 노드를 재활용하면 된다. \r\n\r\n사실, 노드가 겹쳐지더라도 굳이 새 노드를 만들 필요는 없다. 바뀌어야 하는 것은 노드의 값뿐이기 때문에, **기존 노드의 값을 갱신**하여 새로운 트리에 연결해 주었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val = root1->val + root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n두 번째 접근에서 아래 부분은 불필요한 코드다. 두 포인터 모두 `nullptr`인 경우, 그 두 개 중에서 하나만 반환하면 되기 때문이다.\r\n\r\n```cpp\r\nif(root1 == nullptr && root2 == nullptr)\r\n    return nullptr;\r\n```\r\n\r\n이러한 점을 고려하여 최종적으로 리팩토링한 코드는 아래와 같다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val += root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n-----"},{"excerpt":"1. 문제 설명 트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)  2. 제약 조건 한 트리에 있는 노드의 개수는 0개 이상 개 이하다. 노드의 값은  이상  이하다. 3. 접근 트리의 지름은 정의상 어떤 리프 노드에서 다른 리프 노드까지의 경로일 수밖에 없다. 만약 어떤 지름이 리프 노드…","fields":{"slug":"/l-543/"},"frontmatter":{"date":"May 01, 2021","title":"[L543] Diameter of Binary Tree","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)\r\n\r\n![트리의 지름 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 한 트리에 있는 노드의 개수는 0개 이상 $$10^4$$개 이하다.\r\n3. 노드의 값은 $$-100$$ 이상 $$100$$ 이하다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n트리의 지름은 정의상 **어떤 리프 노드에서 다른 리프 노드까지의 경로**일 수밖에 없다. 만약 어떤 지름이 리프 노드가 아닌 노드를 포함하고 있다면, 리프 노드를 선택할 경우 언제나 거리가 늘어나기 때문에 모순이 발생하기 때문이다.\r\n\r\n또한, 트리의 지름은 반드시 **어떤 서브 트리의 루트 노드**를 지나야 한다. 그 루트 노드가 트리 전체의 루트 노드일 필요는 없지만, 한 리프 노드가 다른 리프 노드와 만나기 위해서는 루트 노드를 지나는 것이 필연적이기 때문이다.\r\n\r\n따라서 트리의 모든 노드를 루트 노드라고 가정하고 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구한 후, 그 합의 최댓값을 구하면 트리의 지름을 얻을 수 있을 것이다.\r\n\r\n정리하면, 필요한 연산은 아래와 같다.\r\n\r\n1. 한 노드에서 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구하는 연산\r\n2. 1.에서 구한 최대 깊이의 전체 최댓값을 구하는 연산\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    \r\n    int maxDepth = -1;\r\n    \r\n    int diameterOfBinaryTree(TreeNode* root) {\r\n        \r\n        updateMaxDepth(root);\r\n        return maxDepth;\r\n    \r\n    }\r\n    \r\n    int updateMaxDepth(TreeNode* root){\r\n        \r\n        if(root == nullptr)\r\n            return 0;\r\n        \r\n        int left = updateMaxDepth(root->left);\r\n        int right = updateMaxDepth(root->right);\r\n        \r\n        // 전체 최댓값 갱신\r\n        maxDepth = max(maxDepth, left + right);\r\n        \r\n        // 양쪽 서브 트리의 깊이 중에서 가장 큰 값 + 자기 자신(1)\r\n        return max(left, right) + 1;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 참고한 링크\r\n\r\n포럼에서 [가장 많은 업보트를 받은 코드](https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth)를 참고했다.\r\n\r\n-----"},{"excerpt":"1. 문제 설명 주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.  2. 제약 조건 리스트 내 노드의 개수는 1개부터 개까지 존재한다. 한 노드의 값은 0부터 9까지다. (선택) 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다. 3. 접근 9. Palindrome Number와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트…","fields":{"slug":"/l-234/"},"frontmatter":{"date":"April 30, 2021","title":"[L234] Palindrome Linked List","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.\r\n\r\n![팰린드롬 리스트와 그렇지 않은 리스트](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 리스트 내 노드의 개수는 1개부터 $$10^5$$개까지 존재한다.\r\n1. 한 노드의 값은 0부터 9까지다.\r\n2. <span style=\"color:grey\">(선택)</span> 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n[9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트 내 노드의 개수가 열 개를 넘어가면 자연수로 쳤을 때 10억을 훌쩍 넘기기 때문이다. 하지만 문제의 본질은 같다.\r\n\r\n관건은 입력받은 리스트의 절반을 **뒤집었을 때, 그 뒤집은 부분이 나머지 부분과 같은지** 확인하는 것이다.\r\n\r\n- 홀수 개 노드의 경우 : 1 - 2 - 4 - 2 - 1\r\n- 짝수 개 노드의 경우 : 1 - 5 - 5 - 1\r\n\r\n9번 문제에서는 입력받은 정수에 모듈로 연산과 나눗셈 연산을 시행하여 간단하게 뒤집을 수 있었지만, 이 문제는 **리스트**가 주어지므로 아래와 같은 연산이 필요하다.\r\n\r\n1. 리스트의 중간 노드를 찾아 그 위치를 반환하는 연산\r\n2. 리스트의 절반을 뒤집는 연산\r\n\r\n-----\r\n\r\n### 3-1. 리스트의 중간 노드를 찾는 연산\r\n\r\n가장 먼저 떠오른 방법은 리스트를 순회하여 노드의 총 개수를 구하는 것이었다.\r\n\r\n그렇게 구한 노드의 개수가 홀수 개인 경우 $$\\frac{n}{2} + 1$$번째 노드가 중간 노드이고, 짝수 개인 경우에도 마찬가지로 해당 노드가 뒤집어야 하는 부분의 시작점이다.\r\n\r\n그러나 이 방법은 중간 노드를 한 번의 순회만으로 찾을 수 없다.\r\n\r\n그렇게 해서 나온 방법이 바로 **두 개의 포인터**를 사용하는 방법이다. slow 포인터는 노드를 1개씩 방문하고, fast 포인터는 노드를 2개씩 건너뛰면서 방문한다.\r\n\r\n![두 포인터가 이동하는 모습](two_pointers.jpg)\r\n\r\n이렇게 하면 slow 포인터는 언제나 fast 포인터의 중간 지점을 가리키게 된다. 뒤집을 때는 slow 포인터의 다음 노드를 시작점으로 한다.\r\n\r\n-----\r\n\r\n### 3-2. 리스트의 절반을 뒤집는 연산\r\n\r\n![flip 연산의 원리](reverse-operation.jpg)\r\n\r\nA부터 이동하면서 위와 같은 순서로 포인터를 변경하면 리스트를 뒤집을 수 있다.\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(ListNode* head) {\r\n        \r\n        if(head == nullptr || head->next == nullptr)\r\n            return true;\r\n    \r\n        ListNode* middle = findMiddle(head);\r\n        ListNode* half = flipList(middle->next);\r\n        \r\n        return isSame(head, half);\r\n        \r\n    }\r\n    \r\n    ListNode* findMiddle(ListNode* start){\r\n        \r\n        ListNode* slow = start;\r\n        ListNode* fast = start;\r\n        \r\n        while(fast->next != nullptr && fast->next->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        \r\n        return slow;\r\n        \r\n    }\r\n    \r\n    ListNode* flipList(ListNode* start){\r\n        \r\n        ListNode* store = nullptr;\r\n        ListNode* update = nullptr;\r\n        \r\n        while(start != nullptr){\r\n            store = start->next;\r\n            start->next = update;\r\n            update = start;\r\n            start = store;\r\n        }\r\n        \r\n        return update;\r\n        \r\n    }\r\n    \r\n    bool isSame(ListNode* head, ListNode* half){\r\n        \r\n        while(half != nullptr){\r\n            if(head->val != half->val)\r\n                return false;\r\n            head = head->next;\r\n            half = half->next;\r\n        }\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 예외 처리 및 주의사항\r\n\r\n리스트에 노드가 없거나 노드가 하나인 경우, 무조건 참을 반환한다.\r\n```cpp\r\nbool isPalindrome(ListNode* head) {\r\n    \r\n    if(head == nullptr || head->next == nullptr)\r\n        return true;\r\n\r\n    // ...\r\n\r\n}\r\n```\r\n또한, `half`는 리스트의 중간부터 시작하기 때문에 끝을 더 빨리 맞닥뜨리게 되므로, `half`를 기준으로 반복문의 조건을 설정한다.\r\n\r\n```cpp\r\nbool isSame(ListNode* head, ListNode* half){\r\n    \r\n    while(half != nullptr){\r\n        // ...\r\n    }\r\n    \r\n}\r\n```\r\n-----\r\n\r\n## 6. 재귀를 활용한 풀이\r\n\r\n재귀로 풀이할 수도 있다. 이 경우 콜 스택 때문에 공간 복잡도는 O(n)이 되지만, 아주 짧은 코드로 문제를 해결할 수 있다는 점에서 매력적이다. [아래 코드](https://leetcode.com/problems/palindrome-linked-list/discuss/64490/My-easy-understand-C%2B%2B-solution)는 포럼에서 가장 많은 추천을 받은 C++ 재귀 코드로, 변수명을 리팩토링하여 가져왔다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* forward;\r\n    \r\n    bool isPalindrome(ListNode* head) {\r\n        forward = head;\r\n        return check(head);\r\n    }\r\n    \r\n    bool check(ListNode* backward) {\r\n        if (backward == nullptr) return true;\r\n        \r\n        bool isPal = check(backward->next) && (forward->val == backward->val);\r\n        forward = forward->next;\r\n        \r\n        return isPal;\r\n    }\r\n};\r\n```\r\n여기서 주목해야 할 포인터는 `forward`와 `backward`이다. \r\n\r\n`backward`는 리스트의 끝까지 재귀적으로 방문했다가 반환되면서 거꾸로 돌아오고, `forward`는 `backward`가 한 칸씩 뒤로 이동할 때마다 앞으로 이동하는 **전역 변수**다. 따라서 이 둘을 비교하면 주어진 리스트가 팰린드롬인지 알아낼 수 있게 된다.\r\n\r\n이 접근이 상대적으로 비효율적인 이유는 리스트의 절반만 검사하는 게 아니라 첫번째 노드부터 마지막 노드까지 비교를 전부 진행하기 때문인데, 개선하려면 리스트의 중간 노드에서부터 재귀 호출을 시작해야 한다.\r\n\r\n-----"},{"excerpt":"나머지(Moular) 연산 문제에서 종종 ‘정답을 특정 수로 나눈 나머지는 무엇인가’라는 표현을 찾아볼 수 있다. 이는 자료형(e.g., int, long long etc)이 저장할 수 있는 범위가 한정되어 있기 때문이다. 즉, 너무 긴 자리의 연산을 시키지 않도록 하기 위해 나머지 값만 물어보는 것이다. 핵심은 정답을 다 구하고 나머지 연산을 수행하는 …","fields":{"slug":"/modulo-operation/"},"frontmatter":{"date":"November 29, 2020","title":"나머지(Modular) 연산 및 유용한 정리","tags":["algorithm","mathematics"]},"rawMarkdownBody":"\r\n## 나머지(Moular) 연산\r\n\r\n문제에서 종종 ‘**정답을 특정 수로 나눈 나머지는 무엇인가**’라는 표현을 찾아볼 수 있다. 이는 자료형(e.g., int, long long etc)이 저장할 수 있는 범위가 한정되어 있기 때문이다. 즉, 너무 긴 자리의 연산을 시키지 않도록 하기 위해 나머지 값만 물어보는 것이다.\r\n\r\n\r\n핵심은 **정답을 다 구하고 나머지 연산을 수행하는 게 아니라, 정답이 갱신될 때마다 연산을 수행하는 것**이다. 나머지 연산은 다음과 같은 성질을 지니고 있기 때문이다.\r\n\r\n$$A\\ mod\\ M = (A\\ mod\\ M)\\ mod\\ M$$\r\n\r\n또한, 나머지 연산은 덧셈과 곱셈에서 다음 정리를 만족한다.\r\n\r\n$$(A+B)\\ mod\\ M=((A\\ mod\\ M)+(B\\ mod\\ M))\\ mod\\ M$$\r\n    \r\n$$(A×B)\\ mod\\ M=((A\\ mod\\ M)×(B\\ mod\\ M))\\ mod\\ M$$\r\n    \r\n단, 나누기의 경우에는 위와 같은 공식이 성립하지 않는다. ([Modular Inverse](https://ko.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses)를 구해야 한다.) 그러나 **뺄셈의 경우에는 성립**하며, 이 경우에는 각각의 수에 나머지 연산을 먼저 수행한 결과가 음수가 나올 수 있으므로 **M을 더하고 나머지 연산을 수행한다.**\r\n        \r\n$$(A-B)\\ mod\\ M=((A\\ mod\\ M)-(B\\ mod\\ M)+M)\\ mod\\ M$$\r\n        \r\n뺄셈에 대한 나머지 연산의 예를 들어보면 아래와 같다.\r\n    \r\n$$(6-5)\\ mod\\ 3=\\ 1\\ mod\\ 3=1$$이라고 할 때,\r\n\r\n$$((6\\ mod\\ 3)-(5\\ mod\\ 3))\\ mod\\ 3=(0-2 + 3)\\ mod\\ 3=1\\ mod\\ 3=1$$이다.\r\n\r\n다만 이때 마지막에 M을 더하지 않고, 음수에 모듈로 연산을 수행하면 어떻게 될까? 정답은 **-2일 수도 있고 1일 수도 있다**는 것이다. 프로그래밍 언어에 따라 결과가 다르다. (e.g., C11, C++14에서는 -2가 출력되고, Java와 Python3에서는 1이 출력된다.)\r\n\r\n마지막으로, 뺄셈에도 위 정리가 성립하는 이유는 아래와 같다.\r\n\r\n1. $0≤a\\ mod\\ c <c$이고, $0≤b\\ mod\\ c<c$이다.\r\n2. 따라서 $$-c<(a\\ mod\\ c-b\\ mod\\ c)<c$$이다.\r\n3. 결국 $$(a\\ mod\\ c-b\\ mod\\ c+c)$$는 언제나 0보다 크므로, 이 상태에서 다시 $$c$$로 나누면 원하는 결과를 얻을 수 있다.\r\n\r\n나머지 연산의 위와 같은 성질을 이용하여 풀어볼 수 있는 문제로는 다음이 있다.\r\n\r\n1. [BOJ 4375번 문제 - 1](https://www.acmicpc.net/problem/4375) [(해설)](https://alex-roh.github.io/boj/4375)"}]}},"pageContext":{}},"staticQueryHashes":[]}