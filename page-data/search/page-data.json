{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"1. 문제 설명 트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)  2. 제약 조건 한 트리에 있는 노드의 개수는 0개 이상 개 이하다. 노드의 값은  이상  이하다. 3. 접근 트리의 지름은 정의상 어떤 리프 노드에서 다른 리프 노드까지의 경로일 수밖에 없다. 만약 어떤 지름이 리프 노드…","fields":{"slug":"/l-543/"},"frontmatter":{"date":"May 01, 2021","title":"[L543] Diameter of Binary Tree","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)\r\n\r\n![트리의 지름 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 한 트리에 있는 노드의 개수는 0개 이상 $$10^4$$개 이하다.\r\n3. 노드의 값은 $$-100$$ 이상 $$100$$ 이하다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n트리의 지름은 정의상 **어떤 리프 노드에서 다른 리프 노드까지의 경로**일 수밖에 없다. 만약 어떤 지름이 리프 노드가 아닌 노드를 포함하고 있다면, 리프 노드를 선택할 경우 언제나 거리가 늘어나기 때문에 모순이 발생하기 때문이다.\r\n\r\n또한, 트리의 지름은 반드시 **어떤 서브 트리의 루트 노드**를 지나야 한다. 그 루트 노드가 트리 전체의 루트 노드일 필요는 없지만, 한 리프 노드가 다른 리프 노드와 만나기 위해서는 루트 노드를 지나는 것이 필연적이기 때문이다.\r\n\r\n따라서 트리의 모든 노드를 루트 노드라고 가정하고 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구한 후, 그 합의 최댓값을 구하면 트리의 지름을 얻을 수 있을 것이다.\r\n\r\n정리하면, 필요한 연산은 아래와 같다.\r\n\r\n1. 한 노드에서 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구하는 연산\r\n2. 1.에서 구한 최대 깊이의 전체 최댓값을 구하는 연산\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    \r\n    int maxDepth = -1;\r\n    \r\n    int diameterOfBinaryTree(TreeNode* root) {\r\n        \r\n        updateMaxDepth(root);\r\n        return maxDepth;\r\n    \r\n    }\r\n    \r\n    int updateMaxDepth(TreeNode* root){\r\n        \r\n        if(root == nullptr)\r\n            return 0;\r\n        \r\n        int left = updateMaxDepth(root->left);\r\n        int right = updateMaxDepth(root->right);\r\n        \r\n        // 전체 최댓값 갱신\r\n        maxDepth = max(maxDepth, left + right);\r\n        \r\n        // 양쪽 서브 트리의 깊이 중에서 가장 큰 값 + 자기 자신(1)\r\n        return max(left, right) + 1;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 참고한 링크\r\n\r\n포럼에서 [가장 많은 업보트를 받은 코드](https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth)를 참고했다.\r\n\r\n-----"},{"excerpt":"1. 문제 설명 두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)  2. 제약 조건 병합은 트리의 루트에서부터 이루어져야 한다. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다. 노드의 값은  이상  이하다. 3. 접근 재귀적으로 트리를 DFS 순회하되, 매…","fields":{"slug":"/l-617/"},"frontmatter":{"date":"May 01, 2021","title":"[L617] Merge Two Binary Trees","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)\r\n\r\n![두 이진 트리의 병합 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 병합은 트리의 루트에서부터 이루어져야 한다.\r\n2. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다.\r\n3. 노드의 값은 $$-10^4$$ 이상 $$10^4$$ 이하다.\r\n\r\n-----\r\n## 3. 접근\r\n\r\n\r\n재귀적으로 트리를 DFS 순회하되, 매 단계마다 새로운 노드를 만들었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        TreeNode* root;\r\n        \r\n        if(root1 != nullptr && root2 != nullptr){\r\n            root->val = root1->val + root2->val;\r\n            root->left = mergeTrees(root1->left, root2->left);\r\n            root->right = mergeTrees(root1->right, root2->right);\r\n        }\r\n        else if(root1 != nullptr && root2 == nullptr){\r\n            root->val = root1->val;\r\n            root->left = mergeTrees(root1->left, nullptr);\r\n            root->right = mergeTrees(root1->right, nullptr);\r\n        }\r\n        else if(root1 == nullptr && root2 != nullptr){\r\n            root->val = root2->val;\r\n            root->left = mergeTrees(nullptr, root2->left);\r\n            root->right = mergeTrees(nullptr, root2->right);\r\n        }\r\n        \r\n        return root;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n그러나 이 방식은 좋지 않은데, 굳이 새로 만들 필요가 없는 노드를 생성하고 있다는 점에서 낭비가 발생하기 때문이다. 두 트리의 노드가 겹치지 않으면 기존의 노드를 재활용하면 된다. \r\n\r\n사실, 노드가 겹쳐지더라도 굳이 새 노드를 만들 필요는 없다. 바뀌어야 하는 것은 노드의 값뿐이기 때문에, **기존 노드의 값을 갱신**하여 새로운 트리에 연결해 주었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val = root1->val + root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n두 번째 접근에서 아래 부분은 불필요한 코드다. 두 포인터 모두 `nullptr`인 경우, 그 두 개 중에서 하나만 반환하면 되기 때문이다.\r\n\r\n```cpp\r\nif(root1 == nullptr && root2 == nullptr)\r\n    return nullptr;\r\n```\r\n\r\n이러한 점을 고려하여 최종적으로 리팩토링한 코드는 아래와 같다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val += root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n-----"},{"excerpt":"1. 문제 설명 주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.  2. 제약 조건 리스트 내 노드의 개수는 1개부터 개까지 존재한다. 한 노드의 값은 0부터 9까지다. (선택) 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다. 3. 접근 9. Palindrome Number와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트…","fields":{"slug":"/l-234/"},"frontmatter":{"date":"April 30, 2021","title":"[L234] Palindrome Linked List","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.\r\n\r\n![팰린드롬 리스트와 그렇지 않은 리스트](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 리스트 내 노드의 개수는 1개부터 $$10^5$$개까지 존재한다.\r\n1. 한 노드의 값은 0부터 9까지다.\r\n2. <span style=\"color:grey\">(선택)</span> 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n[9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트 내 노드의 개수가 열 개를 넘어가면 자연수로 쳤을 때 10억을 훌쩍 넘기기 때문이다. 하지만 문제의 본질은 같다.\r\n\r\n관건은 입력받은 리스트의 절반을 **뒤집었을 때, 그 뒤집은 부분이 나머지 부분과 같은지** 확인하는 것이다.\r\n\r\n- 홀수 개 노드의 경우 : 1 - 2 - 4 - 2 - 1\r\n- 짝수 개 노드의 경우 : 1 - 5 - 5 - 1\r\n\r\n9번 문제에서는 입력받은 정수에 모듈로 연산과 나눗셈 연산을 시행하여 간단하게 뒤집을 수 있었지만, 이 문제는 **리스트**가 주어지므로 아래와 같은 연산이 필요하다.\r\n\r\n1. 리스트의 중간 노드를 찾아 그 위치를 반환하는 연산\r\n2. 리스트의 절반을 뒤집는 연산\r\n\r\n-----\r\n\r\n### 3-1. 리스트의 중간 노드를 찾는 연산\r\n\r\n가장 먼저 떠오른 방법은 리스트를 순회하여 노드의 총 개수를 구하는 것이었다.\r\n\r\n그렇게 구한 노드의 개수가 홀수 개인 경우 $$\\frac{n}{2} + 1$$번째 노드가 중간 노드이고, 짝수 개인 경우에도 마찬가지로 해당 노드가 뒤집어야 하는 부분의 시작점이다.\r\n\r\n그러나 이 방법은 중간 노드를 한 번의 순회만으로 찾을 수 없다.\r\n\r\n그렇게 해서 나온 방법이 바로 **두 개의 포인터**를 사용하는 방법이다. slow 포인터는 노드를 1개씩 방문하고, fast 포인터는 노드를 2개씩 건너뛰면서 방문한다.\r\n\r\n![두 포인터가 이동하는 모습](two_pointers.jpg)\r\n\r\n이렇게 하면 slow 포인터는 언제나 fast 포인터의 중간 지점을 가리키게 된다. 뒤집을 때는 slow 포인터의 다음 노드를 시작점으로 한다.\r\n\r\n-----\r\n\r\n### 3-2. 리스트의 절반을 뒤집는 연산\r\n\r\n![flip 연산의 원리](reverse-operation.jpg)\r\n\r\nA부터 이동하면서 위와 같은 순서로 포인터를 변경하면 리스트를 뒤집을 수 있다.\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(ListNode* head) {\r\n        \r\n        if(head == nullptr || head->next == nullptr)\r\n            return true;\r\n    \r\n        ListNode* middle = findMiddle(head);\r\n        ListNode* half = flipList(middle->next);\r\n        \r\n        return isSame(head, half);\r\n        \r\n    }\r\n    \r\n    ListNode* findMiddle(ListNode* start){\r\n        \r\n        ListNode* slow = start;\r\n        ListNode* fast = start;\r\n        \r\n        while(fast->next != nullptr && fast->next->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        \r\n        return slow;\r\n        \r\n    }\r\n    \r\n    ListNode* flipList(ListNode* start){\r\n        \r\n        ListNode* store = nullptr;\r\n        ListNode* update = nullptr;\r\n        \r\n        while(start != nullptr){\r\n            store = start->next;\r\n            start->next = update;\r\n            update = start;\r\n            start = store;\r\n        }\r\n        \r\n        return update;\r\n        \r\n    }\r\n    \r\n    bool isSame(ListNode* head, ListNode* half){\r\n        \r\n        while(half != nullptr){\r\n            if(head->val != half->val)\r\n                return false;\r\n            head = head->next;\r\n            half = half->next;\r\n        }\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 예외 처리 및 주의사항\r\n리스트에 노드가 없거나 노드가 하나인 경우, 무조건 참을 반환한다.\r\n```cpp\r\nbool isPalindrome(ListNode* head) {\r\n    \r\n    if(head == nullptr || head->next == nullptr)\r\n        return true;\r\n\r\n    // ...\r\n\r\n}\r\n```\r\n또한, `half`는 리스트의 중간부터 시작하기 때문에 끝을 더 빨리 맞닥뜨리게 되므로, `half`를 기준으로 반복문의 조건을 설정한다.\r\n\r\n```cpp\r\nbool isSame(ListNode* head, ListNode* half){\r\n    \r\n    while(half != nullptr){\r\n        // ...\r\n    }\r\n    \r\n}\r\n```\r\n-----\r\n\r\n## 6. 재귀를 활용한 풀이\r\n\r\n재귀로 풀이할 수도 있다. 이 경우 콜 스택 때문에 공간 복잡도는 O(n)이 되지만, 아주 짧은 코드로 문제를 해결할 수 있다는 점에서 매력적이다. [아래 코드](https://leetcode.com/problems/palindrome-linked-list/discuss/64490/My-easy-understand-C%2B%2B-solution)는 포럼에서 가장 많은 추천을 받은 C++ 재귀 코드로, 변수명을 리팩토링하여 가져왔다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* forward;\r\n    \r\n    bool isPalindrome(ListNode* head) {\r\n        forward = head;\r\n        return check(head);\r\n    }\r\n    \r\n    bool check(ListNode* backward) {\r\n        if (backward == nullptr) return true;\r\n        \r\n        bool isPal = check(backward->next) && (forward->val == backward->val);\r\n        forward = forward->next;\r\n        \r\n        return isPal;\r\n    }\r\n};\r\n```\r\n여기서 주목해야 할 포인터는 `forward`와 `backward`이다. \r\n\r\n`backward`는 리스트의 끝까지 재귀적으로 방문했다가 반환되면서 거꾸로 돌아오고, `forward`는 `backward`가 한 칸씩 뒤로 이동할 때마다 앞으로 이동하는 **전역 변수**다. 따라서 이 둘을 비교하면 주어진 리스트가 팰린드롬인지 알아낼 수 있게 된다.\r\n\r\n이 접근이 상대적으로 비효율적인 이유는 리스트의 절반만 검사하는 게 아니라 첫번째 노드부터 마지막 노드까지 비교를 전부 진행하기 때문인데, 개선하려면 리스트의 중간 노드에서부터 재귀 호출을 시작해야 한다.\r\n\r\n-----"}]}},"pageContext":{}},"staticQueryHashes":[]}