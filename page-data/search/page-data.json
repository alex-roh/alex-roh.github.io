{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"1. 객체와 자료형 파이썬에서는 메모리에 저장된 모든 데이터를 객체(object)라는 개념으로 처리한다. 자료형(data type)은 그러한 객체가 어떤 값(value)을 가지고, 어떤 행위(operation)를 할 수 있는지 정의한다. 예컨대 파이썬 인터프리터가 1, 2와 같은 정수 리터럴(literal)을 맞닥뜨리면, 파이썬은 이들을 int 객체로 변…","fields":{"slug":"/python-ch1-1/"},"frontmatter":{"date":null,"title":"[1] 파이썬의 기본 개념들","tags":["python"]},"rawMarkdownBody":"\r\n## 1. 객체와 자료형\r\n\r\n파이썬에서는 메모리에 저장된 모든 데이터를 **객체(object)**라는 개념으로 처리한다. **자료형(data type)**은 그러한 객체가 어떤 값(value)을 가지고, 어떤 행위(operation)를 할 수 있는지 정의한다.\r\n\r\n예컨대 파이썬 인터프리터가 1, 2와 같은 정수 리터럴(literal)을 맞닥뜨리면, 파이썬은 이들을 int 객체로 변환하여 메모리에 저장한다. 이 객체를 나중에 다시 불러오고 싶으면 이름을 붙이면 된다. 이렇게 붙여진 객체의 이름을 **변수(variable)**라고 한다.\r\n\r\n```python\r\na = 1 + 2\r\n# 1 + 2의 결과로 3이라는 객체를 만들고 a라는 이름을 붙인다.\r\n```\r\n\r\n이와 달리, 어떤 객체의 정체성은 **메모리에 존재하는 위치**라고 할 수 있다. 두 객체가 같은 객체인지 여부를 알아보려면 메모리의 위치를 확인해야 한다.\r\n\r\n```python\r\nid(a)\r\n# 객체 a가 메모리의 어느 위치에 있는지 알려주는 간접적인 주소를 출력한다.\r\n```\r\n\r\n여기서 알아볼 수 있는 파이썬의 중요한 특징 중 하나가 있는데, 바로 **불변(immutable) 객체**의 개념이다. 아래 코드를 실행하면 메모리의 주소가 다르게 출력되는데, 파이썬에서 정수 자료형은 불변 객체이므로 값을 바꾸면 메모리를 새로 배정해서 객체를 새로 만들기 때문이다. 즉, `=` 연산자를 통해 정수 1을 담고 있는 객체를 가리키는 주소에서 정수 2를 담고 있는 객체로 `a`의 **주소가 바뀌었다**고 할 수 있다.\r\n\r\n```python\r\nid(a)\r\n# 1866154076528\r\na = a + 1\r\nid(a)\r\n# 1866154076560\r\n```\r\n\r\n## 2. 함수\r\n\r\n함수(function)란 추후 불러와서 재사용할 수 있게 기능별로 분류한 코드의 묶음이다. \r\n\r\n```python\r\ndef input_and_output():\r\n  name = input(\"insert your name:\")\r\n  print(\"Welcome\", name)\r\n```\r\n\r\n## 3. 흐름 제어\r\n\r\n파이썬에서는 `if` 및 `else`를 통해 조건에 따라 실행 결과가 달라지도록 흐름을 제어(flow control)할 수 있다.\r\n\r\n```python\r\ni = 10\r\nif i > 1:\r\n  print(\"1 초과\")\r\n\r\n```\r\n\r\n또한, 조건을 넣어 특정 코드를 반복시킬 수도 있다.\r\n\r\n```python\r\nfor i in range(3):\r\n  print(i)\r\n# 0, 1, 2가 출력됨\r\n```\r\n\r\n## 4. 객체\r\n\r\nVS code상에서 객체 이름 뒤에 .(마침표)을 찍으면 객체의 **속성(attribute)**과 **메서드(method)**를 사용할 수 있다.\r\n\r\n```python\r\na = int(1) # 객체 생성\r\nb = a.__add__(1) # 객체의 메서드 사용\r\n```\r\n\r\n또한, `class` 키워드를 사용하여 **사용자 정의 자료형(user defined data type)**을 만들 수도 있다.\r\n\r\n```python\r\nclass MyInt:\r\n  def __init__(self, value):\r\n    self.value = value # 인스턴스 변수\r\n  def print(self): # 메서드\r\n    print(\"내가 만든 자료형\", self.value)\r\n\r\na = MyInt(123) # 객체 생성\r\na.print() # 객체의 메서드 사용\r\n```\r\n\r\n## 5. 모듈\r\n\r\n**모듈(module)**은 코드를 규격화하여 쉽게 가져와 쓸 수 있도록 한 것으로, `import` 키워드를 이용해 외부의 모듈을 불러올 수 있다. \r\n\r\n```python\r\nimport os\r\ntype os # 객체 os의 자료형 : module\r\nos.getcwd() # os 모듈의 getcwd() 메서드 호출\r\n```\r\n\r\n## 6. 숫자 자료형 및 연산\r\n\r\n아래는 파이썬이 기본적으로 제공하는 숫자 자료형이다.\r\n\r\n<center>\r\n\r\n|자료형|종류|예시|특징|\r\n|:---:|:---:|:---:|:---:|\r\n|int|정수|0, 1, -1, 7|**범위 무제한**|\r\n|float|실수|1.0, 3.14, 0.314e2|부동소수점 표현법 (※ C의 double과 동일)|\r\n|complex|복소수|1.0 + 2.0j|실수부와 허수부는 각각 float|\r\n\r\n</center>\r\n\r\n특이한 점은, 파이썬의 정수 자료형은 수의 범위가 (메모리가 허용하는 한) **무한대**라는 것이다. 파이썬은 수가 커지면 해당 객체에 더 많은 메모리를 할당한다.\r\n\r\n```python\r\nimport sys\r\n\r\na = 123\r\nb = 3_903_832_102_389_244_353_548_354_345 # 언더스코어로 끊어읽기 가능\r\n\r\nprint(sys.getsizeof(a)) # 28\r\nprint(sys.getsizeof(b)) # 40\r\n```\r\n\r\n또한 파이썬에서는 `int` 정수형끼리 `/` 연산자를 사용하여 나누더라도 결과가 `int`로 나오지 않는다. 정수 결과값을 얻고 싶다면, 소수점 이하 자리를 버림하여 출력하는 `//` 연산자를 사용하도록 한다.\r\n\r\n```python\r\ntype(4 / 2) # float\r\ntype(7 / 2) # int\r\n```\r\n\r\n그 외 절대값, 몫과 나머지를 한꺼번에 구하는 연산, 거듭제곱 연산자 및 거듭제곱 함수로 아래와 같은 것들이 있다.\r\n\r\n```python\r\nabs(-3) # 3\r\ndivmod(7, 2) ## (3, 1) - 튜플(tuple)\r\n2 ** 3 ## 2^3\r\npow(2, 3) ## 2^3\r\n```\r\n\r\n실수 리터럴을 기입할 때에는 과학적 표기법을 사용할 수도 있다.\r\n\r\n```python\r\n3.1415e2 # 314.15 (3.1415 * 10^2)\r\n```\r\n\r\n또한, 위에서 소수점 이하 자리를 버림하여 정수 값을 출력한다고 설명했던 ``//`` 연산자의 경우, **피연산자 중에 실수 자료형이 하나라도 있으면** 결과는 소수점 이하 자리가 모두 0인 실수 자료형이 되기에 주의해야 한다.\r\n\r\n```python\r\ntype(1.1 // 1) # float\r\nprint(1.1 // 1) # 1.0\r\n```\r\n\r\n또한 실수 자료형의 경우, 연산 속도가 빠르다는 이점을 지닌 부동소수점 표현법이 채택되어 **1) 부호 2) 유효숫자 3) 지수** 세 가지로 저장된다. 예컨대 -3.141592의 경우, 1) - 2) 3141592 3) $$10^{-6}$$으로 나뉜다. 다만 십진수라도 내부적으로는 이진수로 저장되기 때문에, 10진수로 표현하면 정밀도 문제가 발생하게 된다.\r\n\r\n\r\n다시 말해, 소수점 이하 자리를 표현할 때 $$\\frac{1}{2}$$, $$\\frac{1}{4}$$, $$\\frac{1}{8}$$, ... 등의 조합을 사용하기 때문에, 십진수 입장에서는 0.1와 같은 숫자가 제대로 표현되지 않는다. 따라서 수치적 정밀성이 요구되는 분야에서는 부동소수점 표현법으로 발생하는 오차에 대해 잘 이해하고 있어야 한다.\r\n\r\n```python\r\n0.1 * 0.1 # 0.010000000000000002 (매우 작은 자리에서 오차 발생)\r\n```\r\n\r\n(+) 예컨대 아주 큰 숫자와 아주 작은 숫자가 더해지면, 아주 작은 숫자가 무시된다.\r\n\r\n```python\r\n100000000000000000000000.0+ 1.2 # 1e+23\r\n```\r\n\r\n마지막으로 복소수의 경우, 리터럴 안에 j를 붙여 허수부를 표현할 수 있다.\r\n\r\n```python\r\n1 + 2j\r\n```"},{"excerpt":"1. 변수의 이름 변수의 이름을 짓는 규칙은 다음과 같다. 그 변수의 의미와 기능을 가장 짧게 표현할 수 있어야 한다. 알파벳, 숫자 및 언더스코어를 사용한다. 숫자로 시작할 수 없다. 중간에 빈칸을 넣을 수 없다. 기호를 사용할 수 없다. 대소문자를 구분한다. 파이썬에서 이미 용도가 정해진 단어들을 사용하지 않는다. 헷갈리기 쉬운 글자의 사용을 자제한다…","fields":{"slug":"/python-ch1-2/"},"frontmatter":{"date":null,"title":"[2] 파이썬과 변수","tags":["python"]},"rawMarkdownBody":"\r\n## 1. 변수의 이름\r\n\r\n변수의 이름을 짓는 규칙은 다음과 같다.\r\n\r\n1. **그 변수의 의미와 기능을 가장 짧게 표현할 수 있어야 한다.**\r\n2. 알파벳, 숫자 및 언더스코어를 사용한다.\r\n3. 숫자로 시작할 수 없다.\r\n4. 중간에 빈칸을 넣을 수 없다.\r\n5. 기호를 사용할 수 없다.\r\n6. 대소문자를 구분한다.\r\n7. 파이썬에서 이미 용도가 정해진 단어들을 사용하지 않는다.\r\n8. 헷갈리기 쉬운 글자의 사용을 자제한다. (O,0 and 1,l)\r\n\r\n이때 변수의 의미와 기능을 표현하기 위한 두 가지 표기법이 존재한다.\r\n\r\n- 스네이크 케이스 : 단어들을 모두 소문자로 적고 그 사이를 언더스코어로 연결\r\n> snake-case\r\n- 캐멀 케이스 : 단어들의 첫 글자만 대문자로 적어서 구분\r\n> CamelCase\r\n\r\n파이썬의 표준 스타일 권고안 [PEP8](https://peps.python.org/pep-0008/#function-and-variable-names)에서는 **함수 및 변수에 스네이크 케이스**를, **클래스에는 캐멀 케이스**를 권장하고 있다.\r\n\r\n파이썬에서 이미 사용 중인 키워드의 리스트를 보는 방법은 아래와 같다.\r\n\r\n```python\r\nimport keyword\r\nkeyword.kwlist\r\n\r\n# ['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\r\n```\r\n\r\n## 2. 동적 자료형 결정(Dynamic Typing)\r\n\r\n[![파이썬의 동적 자료형 결정](dynamic-typing.jpg)](https://www.youtube.com/watch?v=LqVVzstFT3c)\r\n\r\n파이썬에서는 같은 변수 이름을 여러 자료형의 객체에게 바꿔가며 할당할 수 있다. 자료형을 계속 바꿀 수 있다는 의미에서 동적 자료형 결정(Dynamic Typing)이라고 한다. 이는 C 언어 등의 다른 언어와 비교했을 때 큰 차이점이기 때문에 기억해 두어야 한다.\r\n\r\n```python\r\na = 1\r\nprint(type(a)) # <class 'int'>\r\na = 1.0\r\nprint(type(a)) # <class 'float'>\r\na = \"Hello, World!\"\r\nprint(type(a)) # <class 'str'> \r\n```\r\n\r\n## 3. 가변성과 불변성(Mutablity and Immutability)\r\n\r\n파이썬에서는 변수가 객체를 소유하고 있는 것이 아니라 이름표에 불과하다. 따라서 아래와 같이 같은 객체에 이름표를 두 개 발급할 수도 있다. \r\n\r\n```python\r\na = 123\r\nb = a\r\nprint(id(a), a) # 2183810996400 123\r\nprint(id(b), b) # 2183810996400 123 - same\r\n```\r\n\r\n그러나 이 상태에서 변수 b의 값을 바꾸면, 새로운 값을 갖는 객체를 새로 만들기 때문에 id가 달라지게 된다.\r\n\r\n```python\r\nb = b + 1\r\nprint(id(a), a) # 2183810996400 123\r\nprint(id(b), b) # 2183810996432 124\r\n```\r\n\r\n이는 정수 자료형이 <u>객체의 값을 바꿀 수 없는</u> **불변(immutable) 자료형**이기 때문이다. 파이썬에는 값을 바꿀 수 없는 불변 자료형과 가변(mutable) 자료형이 있는데, 이는 뒤에서 더 자세히 설명하기로 한다.\r\n\r\n<center>\r\n\r\n||불변|가변\r\n:------:|:------:|:------:\r\n**유형**|  int, float, bool, str, tuple  |  list, dict, set\r\n\r\n</center>\r\n\r\n또한 파이썬 문법에서는 변수의 값이 바뀌지 않도록 고정시키는 방법이 존재하지 않는다. 예컨대 반지름이 1.2인 원의 넓이를 구한다고 가정해 보자. 원주율 π는 바뀌지 않는 값이어야 하므로, 상수임을 표현하기 위해 **변수의 이름을 대문자**로 짓는다.\r\n"},{"excerpt":"포매터 사용법 (formatter) 포매터 black을 사용하면 띄어쓰기와 같은 사소한 규칙들은 무시하고 코드의 내용에 집중할 수 있다. 또한, 코드 스타일을 통일시키므로 가독성과 생산성이 증진된다. 포매터 설치 방법 터미널에서 으로 간단하게 설치할 수 있다. 그 후에 VSCode의 설정 화면에서 python formatting provider를 Blac…","fields":{"slug":"/python-formatter/"},"frontmatter":{"date":"June 10, 2022","title":"파이썬 포매터 : Black","tags":["python"]},"rawMarkdownBody":"\r\n## 포매터 사용법 (formatter)\r\n\r\n포매터 [black](https://black.readthedocs.io/en/stable/index.html)을 사용하면 띄어쓰기와 같은 사소한 규칙들은 무시하고 코드의 내용에 집중할 수 있다. 또한, 코드 스타일을 통일시키므로 가독성과 생산성이 증진된다.\r\n\r\n## 포매터 설치 방법\r\n\r\n터미널에서 `pip install black`으로 간단하게 설치할 수 있다. 그 후에 VSCode의 설정 화면에서 python formatting provider를 Black으로 설정하고 format on save에 체크하면, VSCode에서 파이썬 코드를 저장할 때마다 자동으로 포매팅된다.\r\n\r\n## 포매터 사용법\r\n\r\n`black {파일 또는 폴더 이름}`으로 포매팅할 수 있다.\r\n\r\n```bash\r\nblack practice.py\r\n```\r\n\r\n## 코드 포매팅 예제\r\n\r\n[해당 링크](https://black.vercel.app/?version=stable&state=_Td6WFoAAATm1rRGAgAhARYAAAB0L-Wj4ARUAmtdAD2IimZxl1N_WlkPinBFoXIfdFTaTVkGVeHShArYj9yPlDvwBA7LhGo8BvRQqDilPtgsfdKl-ha7EFp0Ma6lY_06IceKiVsJ3BpoICJM9wU1VJLD7l3qd5xTmo78LqThf9uibGWcWCD16LBOn0JK8rhhx_Gf2ClySDJtvm7zQJ1Z-Ipmv9D7I_zhjztfi2UTVsJp7917XToHBm2EoNZqyE8homtGskFIiif5EZthHQvvOj8S2gJx8_t_UpWp1ScpIsD_Xq83LX-B956I_EBIeNoGwZZPFC5zAIoMeiaC1jU-sdOHVucLJM_x-jkzMvK8Utdfvp9MMvKyTfb_BZoe0-FAc2ZVlXEpwYgJVAGdCXv3lQT4bpTXyBwDrDVrUeJDivSSwOvT8tlnuMrXoD1Sk2NZB5SHyNmZsfyAEqLALbUnhkX8hbt5U2yNQRDf1LQhuUIOii6k6H9wnDNRnBiQHUfzKfW1CLiThnuVFjlCxQhJ60u67n3EK38XxHkQdOocJXpBNO51E4-f9z2hj0EDTu_ScuqOiC9cI8qJ4grSZIOnnQLv9WPvmCzx5zib3JacesIxMVvZNQiljq_gL7udm1yeXQjENOrBWbfBEkv1P4izWeAysoJgZUhtZFwKFdoCGt2TXe3xQ-wVZFS5KoMPhGFDZGPKzpK15caQOnWobOHLKaL8eFA-qI44qZrMQ7sSLn04bYeenNR2Vxz7hvK0lJhkgKrpVfUnZrtF-e-ubeeUCThWus4jZbKlFBe2Kroz90Elij_UZBMFCcFo0CfIx5mGlrINrTRFyNsHRkoRBLruYzynsdQIZlZ2M2AAAE3z3tcACOrHAAGHBdUIAADeZ5kXscRn-wIAAAAABFla)에서 확인해볼 수 있다.\r\n"},{"excerpt":"1. 문제 설명 2와 5로 나누어 떨어지지 않는 정수 n이 주어졌을 때, 1로만 이루어진 n의 배수(e.g., 1, 11, 111...)를 찾는 프로그램을 작성하여 그 중 가장 작은 수의 자리수를 출력하시오. 2. 제약 조건 2와 5로 나누어 떨어지지 않는 정수 은 을 만족한다. 각 테스트 케이스는 한 줄로 이루어져 있다. 3. 접근 3-1. 정답이 반드…","fields":{"slug":"/b-4375/"},"frontmatter":{"date":"March 29, 2022","title":"[B4375] 1","tags":["boj","mathematics"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n2와 5로 나누어 떨어지지 않는 정수 n이 주어졌을 때, 1로만 이루어진 n의 배수(e.g., 1, 11, 111...)를 찾는 프로그램을 작성하여 그 중 가장 작은 수의 자리수를 출력하시오.\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 2와 5로 나누어 떨어지지 않는 정수 $$n$$은 $$1 ≤ n ≤ 10000$$을 만족한다.\r\n2. 각 테스트 케이스는 한 줄로 이루어져 있다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n### 3-1. 정답이 반드시 존재하는지 여부 파악\r\n\r\n1, 11, 111, 1111, ...의 규칙을 만족하는 n개의 수가 있다고 가정하자. 1번째부터 n번째까지, 모든 수가 n으로 나누었을 때 서로 나머지가 다르다고 가정하자. 여기서 맨 끝에 하나의 수가 더 추가되어 총 n + 1개의 수가 되면 어떻게 될까? n + 1개의 수들은 n으로 나누었을 때 서로 나머지가 전부 다를 수 있을까?\r\n\r\n정답은 **그렇지 않다**는 것이다. 어떤 수를 n으로 나눈 나머지는 n을 초과할 수 없기 때문이다. 예컨대 n = 9라고 가정하면, 나머지를 0, 1, 2, 3, ..., 9까지 각각 하나씩 가진다고 해도 다 합해서 n개밖에 되지 않기 때문에 n + 1번째 마지막 수는 반드시 저 중에서 하나를 나머지로 가질 수밖에 없다. 이것을 **비둘기집의 원리**라고 한다. 따라서 n + 1개의 수 중에서, 어떤 두 수는 반드시 n으로 나눈 나머지가 같다.\r\n\r\n그리고 그 어떤 두 수가 각각 1111...11과 1111..11이라고 가정할 때, 그 두 수를 뺀 값은 언제나 1111..00의 패턴을 지니며, **나눗셈의 원리**에 의해 그 두 수를 뺀 값은 반드시 n의 배수이다. 문제는 1로만 이루어진 n의 배수를 찾고 있으므로, 해당 값을 10...00으로 나누어서 0을 제외하면 문제의 해를 찾을 수 있다.\r\n\r\n따라서 1, 11, 111, ... 등의 수를 차례대로 n으로 나누어 나가면, 브루트 포스 방식으로 해를 찾을 수 있음이 증명되었다. 문제는 n의 범위가 1부터 10,000까지이기 때문에, 21자리 수부터는 ```long long``` 자료형으로도 연산이 불가능하다는 것이다.\r\n\r\n### 3-2. 나머지 연산의 성질을 이용한 풀이\r\n\r\n여기서 등장하는 것이 바로 **모듈로 연산**이다. 어떤 수가 n의 배수일 경우, 그 수는 n으로 모듈로 연산을 수행했을 때 결과값이 0이 나와야 한다. 즉, **이 문제는 ```1로만 이루어진 임의의 수 % n == 0```이 참인지 묻는 문제**다.\r\n\r\n그리고 이처럼 **정답을 모듈로 연산한 값을 묻는 문제**의 경우 중요한 특징이 하나 있는데, 바로 **중간해를 모듈로 연산한 값**을 정답을 찾는 과정에 활용할 수 있다는 점이다. 모듈로 연산은 아래와 같은 정리를 만족하기 때문이다.\r\n\r\n$$(A+B)\\ mod\\ M=((A\\ mod\\ M)+(B\\ mod\\ M))\\ mod\\ M$$\r\n\r\n$$(A×B)\\ mod\\ M=((A\\ mod\\ M)×(B\\ mod\\ M))\\ mod\\ M$$\r\n\r\n1, 11, 111, 1111, ...와 같은 규칙으로 증가하는 수는 $$(a * 10) + 1$$와 같은 규칙으로 표현할 수 있으며, 문제는 $$(a * 10) + 1 \\ mod\\ n$$한 값이 0인지 묻고 있다. 그렇다면 위 정리를 이용해서 해당 수식을 다르게 표현해보도록 하자.\r\n\r\n$$ (a\\ *\\ 10)+1\\ mod\\ n $$\r\n\r\n$$ = ((a\\ *\\ 10)\\ mod\\ n + 1\\ mod\\ n)\\ mod\\ n$$\r\n\r\n$$ = ((a\\ mod\\ n) *\\ (10\\ mod\\ n))\\ mod\\ n + 1\\ mod\\ n)\\ mod\\ n$$\r\n\r\n또한, $$ (a\\ mod\\ n) \\ mod\\ n = a\\ mod\\ n $$처럼 $$mod$$ 연산을 여러 번 수행하는 것은 **$$mod$$ 연산을 한 번 수행하는 것과 같으므로**, 마지막 수식은 아래와 같이 바꾸어 쓸 수 있다.\r\n\r\n$$ = ((a\\ mod\\ n) *10) + 1)\\ mod\\ n$$\r\n\r\n여기서 주목해야 하는 부분은 $$a\\ mod\\ n$$이다. a는 지난 반복(iteration)의 결과값이기 때문에, 지난 반복에서 **결과값에 $$mod\\ n$$한 값을 이번 반복으로 넘겼다면** $$a\\ mod\\ n$$은 이번 반복에서 곧바로 파악이 가능하다. 무엇보다 이 방식에서 해당 값은 $$n$$을 초과할 수 없기에, 이번 반복에서 **자릿수가 매우 크게 증가하는 것을 방지**할 수 있다.\r\n\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char** argv) {\r\n\r\n\t// freopen(\"input.txt\", \"rt\", stdin);\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL); cout.tie(NULL);\r\n\r\n    int a, n, digit;\r\n\r\n    while(cin >> n){\r\n\r\n        a = 0; digit = 0;\r\n\r\n        while(true){\r\n\t\t\t\r\n\t\t\tdigit++;\r\n            a = 10 * a + 1;\r\n            if(a % n == 0)\r\n            \tbreak;\r\n            else\r\n\t\t\t\ta %= n; // a mod n을 다음 반복으로 넘김\r\n            \t\r\n        }\r\n        \r\n        cout << digit << '\\n';\r\n\r\n    }\r\n\r\n\treturn 0;\r\n}\r\n```\r\n\r\n-----\r\n\r\n## 5. 예외 처리 및 주의사항\r\n\r\n이 문제에서 테스트 입력은 한 줄으로 들어온다. 따라서 케이스 하나만 입력받고 답을 출력하는 게 아니라, **케이스가 끝날 때까지 값을 입력받을 수 있도록** ```while```문의 조건을 ```cin >> n```으로 작성한다. (EOF까지 입력받기 위해 ```while(!cin.eof())```로 작성하자 에러를 냈는데, 정확한 이유는 아직 불명이다.)\r\n\r\n또한 중간값을 모듈로 연산하여 넘기면, 통상적으로 자릿수를 계산하기 위한 알고리즘인 아래 코드를 사용할 수 없다.\r\n\r\n```cpp\r\nvoid count_digit(long long n){\r\n\t\r\n\tint digit = 0;\r\n\t\r\n\twhile(n >= 1){\r\n\t\tdigit++;\r\n\t\tn /= 10;\t\r\n\t}\r\n\t\r\n\tcout << digit << '\\n';\r\n\t\r\n}\r\n```\r\n\r\n그 이유는, **중간값이 계속 모듈로 연산**되며 자릿수가 n의 최대값인 10,000 미만으로 제한되기 때문이다. 따라서 ```while```문 내에서 다음 반복으로 넘어갈 때마다 ```digit```을 1 증가시켜 주는 방식으로 작성하도록 한다.\r\n\r\n\r\n-----"},{"excerpt":"1. HTML이란? HTML은 Hypertext Markup Language의 약자로, 웹 페이지의 구조를 결정한다. HTML을 구성하는 기본 단위는 태그로, HTML에서 사용할 수 있는 태그들은 이미 정의되어 있다 예컨대  태그는 닫는 태그 가 나오기 전까지 텍스트를 크고 두껍게 강조한다. 이처럼 대부분의 HTML 태그는 아래와 같이 사용되고, 이 묶음…","fields":{"slug":"/html-basic/"},"frontmatter":{"date":"March 27, 2022","title":"HTML의 기초","tags":["vanilla-coding","html"]},"rawMarkdownBody":"\r\n## 1. HTML이란?\r\n\r\nHTML은 Hypertext Markup Language의 약자로, 웹 페이지의 구조를 결정한다. HTML을 구성하는 기본 단위는 태그로, HTML에서 사용할 수 있는 태그들은 이미 정의되어 있다 예컨대 ```<h1>``` 태그는 닫는 태그 ```</h1>```가 나오기 전까지 텍스트를 크고 두껍게 강조한다. 이처럼 대부분의 HTML 태그는 아래와 같이 사용되고, 이 묶음을 ```element```라고 한다.\r\n\r\n1. 여는 태그: 어떤 태그를 사용하는지 명시함\r\n2. 해당 태그가 적용되기를 바라는 텍스트 문구\r\n3. 닫는 태그: 해당 태그가 적용되는 끝 지점을 명시"},{"excerpt":"1. 문제 설명 트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)  2. 제약 조건 한 트리에 있는 노드의 개수는 0개 이상 개 이하다. 노드의 값은  이상  이하다. 3. 접근 트리의 지름은 정의상 어떤 리프 노드에서 다른 리프 노드까지의 경로일 수밖에 없다. 만약 어떤 지름이 리프 노드…","fields":{"slug":"/l-543/"},"frontmatter":{"date":"May 01, 2021","title":"[L543] Diameter of Binary Tree","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n트리의 루트 노드가 주어지면 트리의 지름을 반환하시오. (단, 트리의 지름은 두 노드 간 가장 긴 경로를 뜻한다.)\r\n\r\n![트리의 지름 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 한 트리에 있는 노드의 개수는 0개 이상 $$10^4$$개 이하다.\r\n3. 노드의 값은 $$-100$$ 이상 $$100$$ 이하다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n트리의 지름은 정의상 **어떤 리프 노드에서 다른 리프 노드까지의 경로**일 수밖에 없다. 만약 어떤 지름이 리프 노드가 아닌 노드를 포함하고 있다면, 리프 노드를 선택할 경우 언제나 거리가 늘어나기 때문에 모순이 발생하기 때문이다.\r\n\r\n또한, 트리의 지름은 반드시 **어떤 서브 트리의 루트 노드**를 지나야 한다. 그 루트 노드가 트리 전체의 루트 노드일 필요는 없지만, 한 리프 노드가 다른 리프 노드와 만나기 위해서는 루트 노드를 지나는 것이 필연적이기 때문이다.\r\n\r\n따라서 트리의 모든 노드를 루트 노드라고 가정하고 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구한 후, 그 합의 최댓값을 구하면 트리의 지름을 얻을 수 있을 것이다.\r\n\r\n정리하면, 필요한 연산은 아래와 같다.\r\n\r\n1. 한 노드에서 왼쪽과 오른쪽 서브 트리의 최대 깊이를 구하는 연산\r\n2. 1.에서 구한 최대 깊이의 전체 최댓값을 구하는 연산\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    \r\n    int maxDepth = -1;\r\n    \r\n    int diameterOfBinaryTree(TreeNode* root) {\r\n        \r\n        updateMaxDepth(root);\r\n        return maxDepth;\r\n    \r\n    }\r\n    \r\n    int updateMaxDepth(TreeNode* root){\r\n        \r\n        if(root == nullptr)\r\n            return 0;\r\n        \r\n        int left = updateMaxDepth(root->left);\r\n        int right = updateMaxDepth(root->right);\r\n        \r\n        // 전체 최댓값 갱신\r\n        maxDepth = max(maxDepth, left + right);\r\n        \r\n        // 양쪽 서브 트리의 깊이 중에서 가장 큰 값 + 자기 자신(1)\r\n        return max(left, right) + 1;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 참고한 링크\r\n\r\n포럼에서 [가장 많은 업보트를 받은 코드](https://leetcode.com/problems/diameter-of-binary-tree/discuss/101132/Java-Solution-MaxDepth)를 참고했다.\r\n\r\n-----"},{"excerpt":"1. 문제 설명 두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)  2. 제약 조건 병합은 트리의 루트에서부터 이루어져야 한다. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다. 노드의 값은  이상  이하다. 3. 접근 재귀적으로 트리를 DFS 순회하되, 매…","fields":{"slug":"/l-617/"},"frontmatter":{"date":"May 01, 2021","title":"[L617] Merge Two Binary Trees","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n두 이진 트리의 root1과 root2가 주어지면 이 둘을 병합하시오. (단, 겹치는 노드가 있으면 그 둘의 합을 새로운 노드로 한다.)\r\n\r\n![두 이진 트리의 병합 예시](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 병합은 트리의 루트에서부터 이루어져야 한다.\r\n2. 한 트리에 있는 노드의 개수는 0개 이상 2000개 이하다.\r\n3. 노드의 값은 $$-10^4$$ 이상 $$10^4$$ 이하다.\r\n\r\n-----\r\n## 3. 접근\r\n\r\n\r\n재귀적으로 트리를 DFS 순회하되, 매 단계마다 새로운 노드를 만들었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        TreeNode* root;\r\n        \r\n        if(root1 != nullptr && root2 != nullptr){\r\n            root->val = root1->val + root2->val;\r\n            root->left = mergeTrees(root1->left, root2->left);\r\n            root->right = mergeTrees(root1->right, root2->right);\r\n        }\r\n        else if(root1 != nullptr && root2 == nullptr){\r\n            root->val = root1->val;\r\n            root->left = mergeTrees(root1->left, nullptr);\r\n            root->right = mergeTrees(root1->right, nullptr);\r\n        }\r\n        else if(root1 == nullptr && root2 != nullptr){\r\n            root->val = root2->val;\r\n            root->left = mergeTrees(nullptr, root2->left);\r\n            root->right = mergeTrees(nullptr, root2->right);\r\n        }\r\n        \r\n        return root;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n그러나 이 방식은 좋지 않은데, 굳이 새로 만들 필요가 없는 노드를 생성하고 있다는 점에서 낭비가 발생하기 때문이다. 두 트리의 노드가 겹치지 않으면 기존의 노드를 재활용하면 된다. \r\n\r\n사실, 노드가 겹쳐지더라도 굳이 새 노드를 만들 필요는 없다. 바뀌어야 하는 것은 노드의 값뿐이기 때문에, **기존 노드의 값을 갱신**하여 새로운 트리에 연결해 주었다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr && root2 == nullptr)\r\n            return nullptr;\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val = root1->val + root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n두 번째 접근에서 아래 부분은 불필요한 코드다. 두 포인터 모두 `nullptr`인 경우, 그 두 개 중에서 하나만 반환하면 되기 때문이다.\r\n\r\n```cpp\r\nif(root1 == nullptr && root2 == nullptr)\r\n    return nullptr;\r\n```\r\n\r\n이러한 점을 고려하여 최종적으로 리팩토링한 코드는 아래와 같다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\r\n        \r\n        if(root1 == nullptr)\r\n            return root2;\r\n        \r\n        if(root2 == nullptr)\r\n            return root1;\r\n        \r\n        root1->val += root2->val;\r\n        root1->left = mergeTrees(root1->left, root2->left);\r\n        root1->right = mergeTrees(root1->right, root2->right);\r\n        \r\n        return root1;\r\n    \r\n    }\r\n};\r\n```\r\n-----"},{"excerpt":"1. 문제 설명 주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.  2. 제약 조건 리스트 내 노드의 개수는 1개부터 개까지 존재한다. 한 노드의 값은 0부터 9까지다. (선택) 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다. 3. 접근 9. Palindrome Number와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트…","fields":{"slug":"/l-234/"},"frontmatter":{"date":"April 30, 2021","title":"[L234] Palindrome Linked List","tags":["leetcode"]},"rawMarkdownBody":"\r\n## 1. 문제 설명\r\n\r\n주어진 일방향 링크드 리스트가 팰린드롬인지 판별하시오.\r\n\r\n![팰린드롬 리스트와 그렇지 않은 리스트](examples.png)\r\n\r\n-----\r\n\r\n## 2. 제약 조건\r\n\r\n1. 리스트 내 노드의 개수는 1개부터 $$10^5$$개까지 존재한다.\r\n1. 한 노드의 값은 0부터 9까지다.\r\n2. <span style=\"color:grey\">(선택)</span> 시간 복잡도 O(n), 공간 복잡도 O(1)으로 해결해야 한다.\r\n\r\n-----\r\n\r\n## 3. 접근\r\n\r\n[9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)와 비슷한 문제지만, 접근 방식이 조금 달라져야 한다. 리스트 내 노드의 개수가 열 개를 넘어가면 자연수로 쳤을 때 10억을 훌쩍 넘기기 때문이다. 하지만 문제의 본질은 같다.\r\n\r\n관건은 입력받은 리스트의 절반을 **뒤집었을 때, 그 뒤집은 부분이 나머지 부분과 같은지** 확인하는 것이다.\r\n\r\n- 홀수 개 노드의 경우 : 1 - 2 - 4 - 2 - 1\r\n- 짝수 개 노드의 경우 : 1 - 5 - 5 - 1\r\n\r\n9번 문제에서는 입력받은 정수에 모듈로 연산과 나눗셈 연산을 시행하여 간단하게 뒤집을 수 있었지만, 이 문제는 **리스트**가 주어지므로 아래와 같은 연산이 필요하다.\r\n\r\n1. 리스트의 중간 노드를 찾아 그 위치를 반환하는 연산\r\n2. 리스트의 절반을 뒤집는 연산\r\n\r\n-----\r\n\r\n### 3-1. 리스트의 중간 노드를 찾는 연산\r\n\r\n가장 먼저 떠오른 방법은 리스트를 순회하여 노드의 총 개수를 구하는 것이었다.\r\n\r\n그렇게 구한 노드의 개수가 홀수 개인 경우 $$\\frac{n}{2} + 1$$번째 노드가 중간 노드이고, 짝수 개인 경우에도 마찬가지로 해당 노드가 뒤집어야 하는 부분의 시작점이다.\r\n\r\n그러나 이 방법은 중간 노드를 한 번의 순회만으로 찾을 수 없다.\r\n\r\n그렇게 해서 나온 방법이 바로 **두 개의 포인터**를 사용하는 방법이다. slow 포인터는 노드를 1개씩 방문하고, fast 포인터는 노드를 2개씩 건너뛰면서 방문한다.\r\n\r\n![두 포인터가 이동하는 모습](two_pointers.jpg)\r\n\r\n이렇게 하면 slow 포인터는 언제나 fast 포인터의 중간 지점을 가리키게 된다. 뒤집을 때는 slow 포인터의 다음 노드를 시작점으로 한다.\r\n\r\n-----\r\n\r\n### 3-2. 리스트의 절반을 뒤집는 연산\r\n\r\n![flip 연산의 원리](reverse-operation.jpg)\r\n\r\nA부터 이동하면서 위와 같은 순서로 포인터를 변경하면 리스트를 뒤집을 수 있다.\r\n\r\n-----\r\n\r\n## 4. 구현\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n\r\nclass Solution {\r\npublic:\r\n    bool isPalindrome(ListNode* head) {\r\n        \r\n        if(head == nullptr || head->next == nullptr)\r\n            return true;\r\n    \r\n        ListNode* middle = findMiddle(head);\r\n        ListNode* half = flipList(middle->next);\r\n        \r\n        return isSame(head, half);\r\n        \r\n    }\r\n    \r\n    ListNode* findMiddle(ListNode* start){\r\n        \r\n        ListNode* slow = start;\r\n        ListNode* fast = start;\r\n        \r\n        while(fast->next != nullptr && fast->next->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        \r\n        return slow;\r\n        \r\n    }\r\n    \r\n    ListNode* flipList(ListNode* start){\r\n        \r\n        ListNode* store = nullptr;\r\n        ListNode* update = nullptr;\r\n        \r\n        while(start != nullptr){\r\n            store = start->next;\r\n            start->next = update;\r\n            update = start;\r\n            start = store;\r\n        }\r\n        \r\n        return update;\r\n        \r\n    }\r\n    \r\n    bool isSame(ListNode* head, ListNode* half){\r\n        \r\n        while(half != nullptr){\r\n            if(head->val != half->val)\r\n                return false;\r\n            head = head->next;\r\n            half = half->next;\r\n        }\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n};\r\n```\r\n\r\n-----\r\n\r\n## 5. 예외 처리 및 주의사항\r\n\r\n리스트에 노드가 없거나 노드가 하나인 경우, 무조건 참을 반환한다.\r\n```cpp\r\nbool isPalindrome(ListNode* head) {\r\n    \r\n    if(head == nullptr || head->next == nullptr)\r\n        return true;\r\n\r\n    // ...\r\n\r\n}\r\n```\r\n또한, `half`는 리스트의 중간부터 시작하기 때문에 끝을 더 빨리 맞닥뜨리게 되므로, `half`를 기준으로 반복문의 조건을 설정한다.\r\n\r\n```cpp\r\nbool isSame(ListNode* head, ListNode* half){\r\n    \r\n    while(half != nullptr){\r\n        // ...\r\n    }\r\n    \r\n}\r\n```\r\n-----\r\n\r\n## 6. 재귀를 활용한 풀이\r\n\r\n재귀로 풀이할 수도 있다. 이 경우 콜 스택 때문에 공간 복잡도는 O(n)이 되지만, 아주 짧은 코드로 문제를 해결할 수 있다는 점에서 매력적이다. [아래 코드](https://leetcode.com/problems/palindrome-linked-list/discuss/64490/My-easy-understand-C%2B%2B-solution)는 포럼에서 가장 많은 추천을 받은 C++ 재귀 코드로, 변수명을 리팩토링하여 가져왔다.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* forward;\r\n    \r\n    bool isPalindrome(ListNode* head) {\r\n        forward = head;\r\n        return check(head);\r\n    }\r\n    \r\n    bool check(ListNode* backward) {\r\n        if (backward == nullptr) return true;\r\n        \r\n        bool isPal = check(backward->next) && (forward->val == backward->val);\r\n        forward = forward->next;\r\n        \r\n        return isPal;\r\n    }\r\n};\r\n```\r\n여기서 주목해야 할 포인터는 `forward`와 `backward`이다. \r\n\r\n`backward`는 리스트의 끝까지 재귀적으로 방문했다가 반환되면서 거꾸로 돌아오고, `forward`는 `backward`가 한 칸씩 뒤로 이동할 때마다 앞으로 이동하는 **전역 변수**다. 따라서 이 둘을 비교하면 주어진 리스트가 팰린드롬인지 알아낼 수 있게 된다.\r\n\r\n이 접근이 상대적으로 비효율적인 이유는 리스트의 절반만 검사하는 게 아니라 첫번째 노드부터 마지막 노드까지 비교를 전부 진행하기 때문인데, 개선하려면 리스트의 중간 노드에서부터 재귀 호출을 시작해야 한다.\r\n\r\n-----"},{"excerpt":"나머지(Moular) 연산 문제에서 종종 ‘정답을 특정 수로 나눈 나머지는 무엇인가’라는 표현을 찾아볼 수 있다. 이는 자료형(e.g., int, long long etc)이 저장할 수 있는 범위가 한정되어 있기 때문이다. 즉, 너무 긴 자리의 연산을 시키지 않도록 하기 위해 나머지 값만 물어보는 것이다. 핵심은 정답을 다 구하고 나머지 연산을 수행하는 …","fields":{"slug":"/modulo-operation/"},"frontmatter":{"date":"November 29, 2020","title":"나머지(Modular) 연산 및 유용한 정리","tags":["algorithm","mathematics"]},"rawMarkdownBody":"\r\n## 나머지(Moular) 연산\r\n\r\n문제에서 종종 ‘**정답을 특정 수로 나눈 나머지는 무엇인가**’라는 표현을 찾아볼 수 있다. 이는 자료형(e.g., int, long long etc)이 저장할 수 있는 범위가 한정되어 있기 때문이다. 즉, 너무 긴 자리의 연산을 시키지 않도록 하기 위해 나머지 값만 물어보는 것이다.\r\n\r\n\r\n핵심은 **정답을 다 구하고 나머지 연산을 수행하는 게 아니라, 정답이 갱신될 때마다 연산을 수행하는 것**이다. 나머지 연산은 다음과 같은 성질을 지니고 있기 때문이다.\r\n\r\n$$A\\ mod\\ M = (A\\ mod\\ M)\\ mod\\ M$$\r\n\r\n또한, 나머지 연산은 덧셈과 곱셈에서 다음 정리를 만족한다.\r\n\r\n$$(A+B)\\ mod\\ M=((A\\ mod\\ M)+(B\\ mod\\ M))\\ mod\\ M$$\r\n    \r\n$$(A×B)\\ mod\\ M=((A\\ mod\\ M)×(B\\ mod\\ M))\\ mod\\ M$$\r\n    \r\n단, 나누기의 경우에는 위와 같은 공식이 성립하지 않는다. ([Modular Inverse](https://ko.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses)를 구해야 한다.) 그러나 **뺄셈의 경우에는 성립**하며, 이 경우에는 각각의 수에 나머지 연산을 먼저 수행한 결과가 음수가 나올 수 있으므로 **M을 더하고 나머지 연산을 수행한다.**\r\n        \r\n$$(A-B)\\ mod\\ M=((A\\ mod\\ M)-(B\\ mod\\ M)+M)\\ mod\\ M$$\r\n        \r\n뺄셈에 대한 나머지 연산의 예를 들어보면 아래와 같다.\r\n    \r\n$$(6-5)\\ mod\\ 3=\\ 1\\ mod\\ 3=1$$이라고 할 때,\r\n\r\n$$((6\\ mod\\ 3)-(5\\ mod\\ 3))\\ mod\\ 3=(0-2 + 3)\\ mod\\ 3=1\\ mod\\ 3=1$$이다.\r\n\r\n다만 이때 마지막에 M을 더하지 않고, 음수에 모듈로 연산을 수행하면 어떻게 될까? 정답은 **-2일 수도 있고 1일 수도 있다**는 것이다. 프로그래밍 언어에 따라 결과가 다르다. (e.g., C11, C++14에서는 -2가 출력되고, Java와 Python3에서는 1이 출력된다.)\r\n\r\n마지막으로, 뺄셈에도 위 정리가 성립하는 이유는 아래와 같다.\r\n\r\n1. $0≤a\\ mod\\ c <c$이고, $0≤b\\ mod\\ c<c$이다.\r\n2. 따라서 $$-c<(a\\ mod\\ c-b\\ mod\\ c)<c$$이다.\r\n3. 결국 $$(a\\ mod\\ c-b\\ mod\\ c+c)$$는 언제나 0보다 크므로, 이 상태에서 다시 $$c$$로 나누면 원하는 결과를 얻을 수 있다.\r\n\r\n나머지 연산의 위와 같은 성질을 이용하여 풀어볼 수 있는 문제로는 다음이 있다.\r\n\r\n1. [BOJ 4375번 문제 - 1](https://www.acmicpc.net/problem/4375) [(해설)](https://alex-roh.github.io/boj/4375)"}]}},"pageContext":{}},"staticQueryHashes":[]}